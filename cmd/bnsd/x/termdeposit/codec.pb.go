// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cmd/bnsd/x/termdeposit/codec.proto

package termdeposit

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_iov_one_weave "github.com/iov-one/weave"
	weave "github.com/iov-one/weave"
	coin "github.com/iov-one/weave/coin"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// DepositContract is an entity created in order to allow investment deposits.
// Anyone can deposit funds and therefore sign a deposit contract in order to
// lock funds and receive appropriate interest after the contract expires.
type DepositContract struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Valid since defines the beginning of when the contract is active.
	ValidSince github_com_iov_one_weave.UnixTime `protobuf:"varint,2,opt,name=valid_since,json=validSince,proto3,casttype=github.com/iov-one/weave.UnixTime" json:"valid_since,omitempty"`
	// An expiration date for this deposit contract. After this deadline, all
	// depositor funds are released and deposit contract is no longer active.
	ValidUntil github_com_iov_one_weave.UnixTime `protobuf:"varint,3,opt,name=valid_until,json=validUntil,proto3,casttype=github.com/iov-one/weave.UnixTime" json:"valid_until,omitempty"`
}

func (m *DepositContract) Reset()         { *m = DepositContract{} }
func (m *DepositContract) String() string { return proto.CompactTextString(m) }
func (*DepositContract) ProtoMessage()    {}
func (*DepositContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_a75d003f77d30257, []int{0}
}
func (m *DepositContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositContract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositContract.Merge(m, src)
}
func (m *DepositContract) XXX_Size() int {
	return m.Size()
}
func (m *DepositContract) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositContract.DiscardUnknown(m)
}

var xxx_messageInfo_DepositContract proto.InternalMessageInfo

func (m *DepositContract) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DepositContract) GetValidSince() github_com_iov_one_weave.UnixTime {
	if m != nil {
		return m.ValidSince
	}
	return 0
}

func (m *DepositContract) GetValidUntil() github_com_iov_one_weave.UnixTime {
	if m != nil {
		return m.ValidUntil
	}
	return 0
}

// Deposit represents a single fund deposition. Deposited funds are locked
// until the contract expiration.
type Deposit struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Deposit contract ID that this funds allocation was made with.
	DepositContractID []byte `protobuf:"bytes,2,opt,name=deposit_contract_id,json=depositContractId,proto3" json:"deposit_contract_id,omitempty"`
	// Total amount that was deposited within a contract. Must be IOV tokens.
	// This information is used when computing each depositor reward. It is used
	// instead of looking at the actual wallet state, so that it is not possible
	// to increase the value of a deposit wallet only shortly before the
	// computation.
	Amount coin.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
	// Pro-rated interest rate as detailed in the Confluence spec.
	Rate Frac `protobuf:"bytes,4,opt,name=rate,proto3" json:"rate"`
	// Payback is an address that locked funds and interest are send back to once
	// the contract expires.
	Depositor github_com_iov_one_weave.Address `protobuf:"bytes,5,opt,name=depositor,proto3,casttype=github.com/iov-one/weave.Address" json:"depositor,omitempty"`
	// Released flag is used to determin whether the funds locked by this deposit
	// were already released or not.
	Released bool `protobuf:"varint,6,opt,name=released,proto3" json:"released,omitempty"`
	// CreatedAt is set to the wall clock value at the deposit creation time.
	CreatedAt github_com_iov_one_weave.UnixTime `protobuf:"varint,7,opt,name=created_at,json=createdAt,proto3,casttype=github.com/iov-one/weave.UnixTime" json:"created_at,omitempty"`
}

func (m *Deposit) Reset()         { *m = Deposit{} }
func (m *Deposit) String() string { return proto.CompactTextString(m) }
func (*Deposit) ProtoMessage()    {}
func (*Deposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_a75d003f77d30257, []int{1}
}
func (m *Deposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deposit.Merge(m, src)
}
func (m *Deposit) XXX_Size() int {
	return m.Size()
}
func (m *Deposit) XXX_DiscardUnknown() {
	xxx_messageInfo_Deposit.DiscardUnknown(m)
}

var xxx_messageInfo_Deposit proto.InternalMessageInfo

func (m *Deposit) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Deposit) GetDepositContractID() []byte {
	if m != nil {
		return m.DepositContractID
	}
	return nil
}

func (m *Deposit) GetAmount() coin.Coin {
	if m != nil {
		return m.Amount
	}
	return coin.Coin{}
}

func (m *Deposit) GetRate() Frac {
	if m != nil {
		return m.Rate
	}
	return Frac{}
}

func (m *Deposit) GetDepositor() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Depositor
	}
	return nil
}

func (m *Deposit) GetReleased() bool {
	if m != nil {
		return m.Released
	}
	return false
}

func (m *Deposit) GetCreatedAt() github_com_iov_one_weave.UnixTime {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

// A Frac represents a quotient numerator/denominator of arbitrary precision.
type Frac struct {
	Numerator   int64 `protobuf:"varint,1,opt,name=numerator,proto3" json:"numerator,omitempty"`
	Denominator int64 `protobuf:"varint,2,opt,name=denominator,proto3" json:"denominator,omitempty"`
}

func (m *Frac) Reset()         { *m = Frac{} }
func (m *Frac) String() string { return proto.CompactTextString(m) }
func (*Frac) ProtoMessage()    {}
func (*Frac) Descriptor() ([]byte, []int) {
	return fileDescriptor_a75d003f77d30257, []int{2}
}
func (m *Frac) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Frac) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Frac.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Frac) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Frac.Merge(m, src)
}
func (m *Frac) XXX_Size() int {
	return m.Size()
}
func (m *Frac) XXX_DiscardUnknown() {
	xxx_messageInfo_Frac.DiscardUnknown(m)
}

var xxx_messageInfo_Frac proto.InternalMessageInfo

func (m *Frac) GetNumerator() int64 {
	if m != nil {
		return m.Numerator
	}
	return 0
}

func (m *Frac) GetDenominator() int64 {
	if m != nil {
		return m.Denominator
	}
	return 0
}

// Configuration is a dynamic configuration used by this extension, managed by
// the functionality provided by gconf package.
type Configuration struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Owner is present to implement gconf.OwnedConfig interface. Owner is
	// allowed to update the configuration.
	Owner github_com_iov_one_weave.Address `protobuf:"bytes,2,opt,name=owner,proto3,casttype=github.com/iov-one/weave.Address" json:"owner,omitempty"`
	// Admin is an address that is able to create deposit contracts.
	Admin github_com_iov_one_weave.Address `protobuf:"bytes,3,opt,name=admin,proto3,casttype=github.com/iov-one/weave.Address" json:"admin,omitempty"`
	// A list of bonus values applied to each created Deposit instance.
	Bonuses []DepositBonus `protobuf:"bytes,4,rep,name=bonuses,proto3" json:"bonuses"`
	// Base rates defines a list of addresses that have their q-score value fixed.
	BaseRates []CustomRate `protobuf:"bytes,5,rep,name=base_rates,json=baseRates,proto3" json:"base_rates"`
}

func (m *Configuration) Reset()         { *m = Configuration{} }
func (m *Configuration) String() string { return proto.CompactTextString(m) }
func (*Configuration) ProtoMessage()    {}
func (*Configuration) Descriptor() ([]byte, []int) {
	return fileDescriptor_a75d003f77d30257, []int{3}
}
func (m *Configuration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Configuration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Configuration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Configuration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Configuration.Merge(m, src)
}
func (m *Configuration) XXX_Size() int {
	return m.Size()
}
func (m *Configuration) XXX_DiscardUnknown() {
	xxx_messageInfo_Configuration.DiscardUnknown(m)
}

var xxx_messageInfo_Configuration proto.InternalMessageInfo

func (m *Configuration) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Configuration) GetOwner() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *Configuration) GetAdmin() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *Configuration) GetBonuses() []DepositBonus {
	if m != nil {
		return m.Bonuses
	}
	return nil
}

func (m *Configuration) GetBaseRates() []CustomRate {
	if m != nil {
		return m.BaseRates
	}
	return nil
}

// Custom Rate allows to declare a fixed qscore value for an address.
type CustomRate struct {
	Address github_com_iov_one_weave.Address `protobuf:"bytes,1,opt,name=address,proto3,casttype=github.com/iov-one/weave.Address" json:"address,omitempty"`
	Qscore  float32                          `protobuf:"fixed32,2,opt,name=qscore,proto3" json:"qscore,omitempty"`
}

func (m *CustomRate) Reset()         { *m = CustomRate{} }
func (m *CustomRate) String() string { return proto.CompactTextString(m) }
func (*CustomRate) ProtoMessage()    {}
func (*CustomRate) Descriptor() ([]byte, []int) {
	return fileDescriptor_a75d003f77d30257, []int{4}
}
func (m *CustomRate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomRate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CustomRate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CustomRate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomRate.Merge(m, src)
}
func (m *CustomRate) XXX_Size() int {
	return m.Size()
}
func (m *CustomRate) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomRate.DiscardUnknown(m)
}

var xxx_messageInfo_CustomRate proto.InternalMessageInfo

func (m *CustomRate) GetAddress() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *CustomRate) GetQscore() float32 {
	if m != nil {
		return m.Qscore
	}
	return 0
}

// DepositBonus defines a bonus value used to calculate deposit rate. The
// longer the deposit period, the higher the deposit bonus should be.
type DepositBonus struct {
	// Deposit minimal lockin period required to use this bonus.
	LockinPeriod github_com_iov_one_weave.UnixDuration `protobuf:"varint,1,opt,name=lockin_period,json=lockinPeriod,proto3,casttype=github.com/iov-one/weave.UnixDuration" json:"lockin_period,omitempty"`
	// A percentage value of the deposit value; Value of 1 represents 1%.
	BonusPercentage int32 `protobuf:"varint,2,opt,name=bonus_percentage,json=bonusPercentage,proto3" json:"bonus_percentage,omitempty"`
}

func (m *DepositBonus) Reset()         { *m = DepositBonus{} }
func (m *DepositBonus) String() string { return proto.CompactTextString(m) }
func (*DepositBonus) ProtoMessage()    {}
func (*DepositBonus) Descriptor() ([]byte, []int) {
	return fileDescriptor_a75d003f77d30257, []int{5}
}
func (m *DepositBonus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositBonus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositBonus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositBonus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositBonus.Merge(m, src)
}
func (m *DepositBonus) XXX_Size() int {
	return m.Size()
}
func (m *DepositBonus) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositBonus.DiscardUnknown(m)
}

var xxx_messageInfo_DepositBonus proto.InternalMessageInfo

func (m *DepositBonus) GetLockinPeriod() github_com_iov_one_weave.UnixDuration {
	if m != nil {
		return m.LockinPeriod
	}
	return 0
}

func (m *DepositBonus) GetBonusPercentage() int32 {
	if m != nil {
		return m.BonusPercentage
	}
	return 0
}

// CreateDepositContractMsg creates a new DepositContract entity. This message
// must be signed by the admin as configured via the Configuration entity.
type CreateDepositContractMsg struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// An activation date for the newly created deposit contract.
	ValidSince github_com_iov_one_weave.UnixTime `protobuf:"varint,2,opt,name=valid_since,json=validSince,proto3,casttype=github.com/iov-one/weave.UnixTime" json:"valid_since,omitempty"`
	// An expiration date for the newly created deposit contract.
	ValidUntil github_com_iov_one_weave.UnixTime `protobuf:"varint,3,opt,name=valid_until,json=validUntil,proto3,casttype=github.com/iov-one/weave.UnixTime" json:"valid_until,omitempty"`
}

func (m *CreateDepositContractMsg) Reset()         { *m = CreateDepositContractMsg{} }
func (m *CreateDepositContractMsg) String() string { return proto.CompactTextString(m) }
func (*CreateDepositContractMsg) ProtoMessage()    {}
func (*CreateDepositContractMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_a75d003f77d30257, []int{6}
}
func (m *CreateDepositContractMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDepositContractMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDepositContractMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDepositContractMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDepositContractMsg.Merge(m, src)
}
func (m *CreateDepositContractMsg) XXX_Size() int {
	return m.Size()
}
func (m *CreateDepositContractMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDepositContractMsg.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDepositContractMsg proto.InternalMessageInfo

func (m *CreateDepositContractMsg) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreateDepositContractMsg) GetValidSince() github_com_iov_one_weave.UnixTime {
	if m != nil {
		return m.ValidSince
	}
	return 0
}

func (m *CreateDepositContractMsg) GetValidUntil() github_com_iov_one_weave.UnixTime {
	if m != nil {
		return m.ValidUntil
	}
	return 0
}

// DepositMsg can be send by anyone to deposit funds within a non expired
// contract. Funds will stay locked until that contract expiration date.
type DepositMsg struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Deposit contract ID that this funds allocation was made with. Contract
	// must not be expired.
	DepositContractID []byte `protobuf:"bytes,2,opt,name=deposit_contract_id,json=depositContractId,proto3" json:"deposit_contract_id,omitempty"`
	// Total amount that was deposited within a contract. Must be IOV tokens.
	Amount coin.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
	// Payback is an address that locked funds and interest are send back to once
	// the contract expires.
	Depositor github_com_iov_one_weave.Address `protobuf:"bytes,4,opt,name=depositor,proto3,casttype=github.com/iov-one/weave.Address" json:"depositor,omitempty"`
}

func (m *DepositMsg) Reset()         { *m = DepositMsg{} }
func (m *DepositMsg) String() string { return proto.CompactTextString(m) }
func (*DepositMsg) ProtoMessage()    {}
func (*DepositMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_a75d003f77d30257, []int{7}
}
func (m *DepositMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositMsg.Merge(m, src)
}
func (m *DepositMsg) XXX_Size() int {
	return m.Size()
}
func (m *DepositMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositMsg.DiscardUnknown(m)
}

var xxx_messageInfo_DepositMsg proto.InternalMessageInfo

func (m *DepositMsg) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DepositMsg) GetDepositContractID() []byte {
	if m != nil {
		return m.DepositContractID
	}
	return nil
}

func (m *DepositMsg) GetAmount() coin.Coin {
	if m != nil {
		return m.Amount
	}
	return coin.Coin{}
}

func (m *DepositMsg) GetDepositor() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Depositor
	}
	return nil
}

// ReleaseDepositMsg cause releasing of all funds allocated within given
// deposit. Related contract must be expired. Anyone can submit this message.
type ReleaseDepositMsg struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// ID of the deposit that is to be released.
	DepositID []byte `protobuf:"bytes,2,opt,name=deposit_id,json=depositId,proto3" json:"deposit_id,omitempty"`
}

func (m *ReleaseDepositMsg) Reset()         { *m = ReleaseDepositMsg{} }
func (m *ReleaseDepositMsg) String() string { return proto.CompactTextString(m) }
func (*ReleaseDepositMsg) ProtoMessage()    {}
func (*ReleaseDepositMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_a75d003f77d30257, []int{8}
}
func (m *ReleaseDepositMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReleaseDepositMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReleaseDepositMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReleaseDepositMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReleaseDepositMsg.Merge(m, src)
}
func (m *ReleaseDepositMsg) XXX_Size() int {
	return m.Size()
}
func (m *ReleaseDepositMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ReleaseDepositMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ReleaseDepositMsg proto.InternalMessageInfo

func (m *ReleaseDepositMsg) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ReleaseDepositMsg) GetDepositID() []byte {
	if m != nil {
		return m.DepositID
	}
	return nil
}

type UpdateConfigurationMsg struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Patch    *Configuration  `protobuf:"bytes,2,opt,name=patch,proto3" json:"patch,omitempty"`
}

func (m *UpdateConfigurationMsg) Reset()         { *m = UpdateConfigurationMsg{} }
func (m *UpdateConfigurationMsg) String() string { return proto.CompactTextString(m) }
func (*UpdateConfigurationMsg) ProtoMessage()    {}
func (*UpdateConfigurationMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_a75d003f77d30257, []int{9}
}
func (m *UpdateConfigurationMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateConfigurationMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateConfigurationMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateConfigurationMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateConfigurationMsg.Merge(m, src)
}
func (m *UpdateConfigurationMsg) XXX_Size() int {
	return m.Size()
}
func (m *UpdateConfigurationMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateConfigurationMsg.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateConfigurationMsg proto.InternalMessageInfo

func (m *UpdateConfigurationMsg) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *UpdateConfigurationMsg) GetPatch() *Configuration {
	if m != nil {
		return m.Patch
	}
	return nil
}

func init() {
	proto.RegisterType((*DepositContract)(nil), "termdeposit.DepositContract")
	proto.RegisterType((*Deposit)(nil), "termdeposit.Deposit")
	proto.RegisterType((*Frac)(nil), "termdeposit.Frac")
	proto.RegisterType((*Configuration)(nil), "termdeposit.Configuration")
	proto.RegisterType((*CustomRate)(nil), "termdeposit.CustomRate")
	proto.RegisterType((*DepositBonus)(nil), "termdeposit.DepositBonus")
	proto.RegisterType((*CreateDepositContractMsg)(nil), "termdeposit.CreateDepositContractMsg")
	proto.RegisterType((*DepositMsg)(nil), "termdeposit.DepositMsg")
	proto.RegisterType((*ReleaseDepositMsg)(nil), "termdeposit.ReleaseDepositMsg")
	proto.RegisterType((*UpdateConfigurationMsg)(nil), "termdeposit.UpdateConfigurationMsg")
}

func init() { proto.RegisterFile("cmd/bnsd/x/termdeposit/codec.proto", fileDescriptor_a75d003f77d30257) }

var fileDescriptor_a75d003f77d30257 = []byte{
	// 728 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x55, 0x4f, 0x6f, 0xd3, 0x30,
	0x14, 0x6f, 0xfa, 0x77, 0x7d, 0xd9, 0xb4, 0xd5, 0xc0, 0x08, 0x15, 0x6a, 0x4b, 0xc4, 0xa4, 0x4e,
	0x83, 0x14, 0x95, 0x13, 0x08, 0x21, 0xad, 0x2d, 0x93, 0x76, 0x18, 0x9a, 0x02, 0x3b, 0x57, 0x6e,
	0x6c, 0x3a, 0x8b, 0xc6, 0x2e, 0x89, 0xbb, 0xed, 0x2b, 0x70, 0xe3, 0x8b, 0xf0, 0x3d, 0x76, 0x42,
	0xbb, 0xc1, 0xa9, 0x42, 0xdd, 0x9d, 0x0f, 0xd0, 0x13, 0x8a, 0xe3, 0xb5, 0xe9, 0x24, 0xd0, 0xba,
	0x03, 0x12, 0xb7, 0xf8, 0xbd, 0xf7, 0x7b, 0xf6, 0xef, 0xf7, 0xb3, 0x5f, 0xc0, 0xf6, 0x7c, 0xd2,
	0xe8, 0xf1, 0x90, 0x34, 0xce, 0x1a, 0x92, 0x06, 0x3e, 0xa1, 0x43, 0x11, 0x32, 0xd9, 0xf0, 0x04,
	0xa1, 0x9e, 0x33, 0x0c, 0x84, 0x14, 0xc8, 0x4c, 0x24, 0xca, 0x66, 0x22, 0x53, 0xde, 0xf0, 0x04,
	0xe3, 0xc9, 0xda, 0xf2, 0xdd, 0xbe, 0xe8, 0x0b, 0xf5, 0xd9, 0x88, 0xbe, 0xe2, 0xa8, 0xfd, 0xcd,
	0x80, 0xf5, 0x4e, 0xdc, 0xa0, 0x2d, 0xb8, 0x0c, 0xb0, 0x27, 0xd1, 0x0e, 0xac, 0xf8, 0x54, 0x62,
	0x82, 0x25, 0xb6, 0x8c, 0x9a, 0x51, 0x37, 0x9b, 0xeb, 0xce, 0x29, 0xc5, 0x27, 0xd4, 0x39, 0xd0,
	0x61, 0x77, 0x56, 0x80, 0xf6, 0xc0, 0x3c, 0xc1, 0x03, 0x46, 0xba, 0x21, 0xe3, 0x1e, 0xb5, 0xd2,
	0x35, 0xa3, 0x9e, 0x69, 0x6d, 0x4d, 0xc7, 0xd5, 0x47, 0x7d, 0x26, 0x8f, 0x47, 0x3d, 0xc7, 0x13,
	0x7e, 0x83, 0x89, 0x93, 0xa7, 0x82, 0xd3, 0x46, 0xdc, 0xe5, 0x88, 0xb3, 0xb3, 0xf7, 0xcc, 0xa7,
	0x2e, 0x28, 0xe4, 0xbb, 0x08, 0x38, 0xef, 0x33, 0xe2, 0x92, 0x0d, 0xac, 0xcc, 0xf2, 0x7d, 0x8e,
	0x22, 0xa0, 0x3d, 0x4d, 0x43, 0x41, 0x13, 0x5a, 0x8e, 0xc8, 0x1b, 0xb8, 0xa3, 0x95, 0xec, 0x7a,
	0x5a, 0x89, 0x2e, 0x23, 0x8a, 0xd0, 0x6a, 0xeb, 0xde, 0x64, 0x5c, 0x2d, 0x5d, 0xd3, 0x69, 0xbf,
	0xe3, 0x96, 0xc8, 0xb5, 0x10, 0x41, 0x75, 0xc8, 0x63, 0x5f, 0x8c, 0xb8, 0x54, 0x14, 0xcc, 0x26,
	0x38, 0x91, 0x13, 0x4e, 0x5b, 0x30, 0xde, 0xca, 0x9e, 0x8f, 0xab, 0x29, 0x57, 0xe7, 0xd1, 0x0e,
	0x64, 0x03, 0x2c, 0xa9, 0x95, 0x55, 0x75, 0x25, 0x27, 0xe1, 0xa5, 0xb3, 0x17, 0x60, 0x4f, 0x97,
	0xab, 0x22, 0xd4, 0x82, 0xa2, 0xce, 0x89, 0xc0, 0xca, 0xa9, 0x33, 0x3d, 0x9e, 0x8e, 0xab, 0xb5,
	0x3f, 0x8a, 0xb3, 0x4b, 0x48, 0x40, 0xc3, 0xd0, 0x9d, 0xc3, 0x50, 0x19, 0x56, 0x02, 0x3a, 0xa0,
	0x38, 0xa4, 0xc4, 0xca, 0xd7, 0x8c, 0xfa, 0x8a, 0x3b, 0x5b, 0xa3, 0x0e, 0x80, 0x17, 0x50, 0x2c,
	0x29, 0xe9, 0x62, 0x69, 0x15, 0x96, 0x51, 0xbf, 0xa8, 0x81, 0xbb, 0xd2, 0xde, 0x83, 0x6c, 0x74,
	0x72, 0xf4, 0x10, 0x8a, 0x7c, 0xe4, 0xd3, 0x00, 0x47, 0xa7, 0x8d, 0x94, 0xcf, 0xb8, 0xf3, 0x00,
	0xaa, 0x81, 0x49, 0x28, 0x17, 0x3e, 0xe3, 0x2a, 0xaf, 0xae, 0x8c, 0x9b, 0x0c, 0xd9, 0x5f, 0xd3,
	0xb0, 0xd6, 0x16, 0xfc, 0x03, 0xeb, 0x8f, 0x02, 0x2c, 0x99, 0xe0, 0xcb, 0x59, 0xf9, 0x12, 0x72,
	0xe2, 0x94, 0xd3, 0x40, 0x9b, 0x77, 0x33, 0xa1, 0x62, 0x48, 0x84, 0xc5, 0xc4, 0x67, 0x5c, 0xd9,
	0x77, 0x63, 0xac, 0x82, 0xa0, 0x17, 0x50, 0xe8, 0x09, 0x3e, 0x0a, 0x69, 0x68, 0x65, 0x6b, 0x99,
	0xba, 0xd9, 0x7c, 0xb0, 0x60, 0xaa, 0xbe, 0x3f, 0xad, 0xa8, 0x44, 0x9b, 0x7b, 0x55, 0x8f, 0x5e,
	0x01, 0xf4, 0x70, 0x48, 0xbb, 0x91, 0xd9, 0xa1, 0x95, 0x53, 0xe8, 0xfb, 0x0b, 0xe8, 0xf6, 0x28,
	0x94, 0xc2, 0x77, 0xb1, 0xa4, 0x1a, 0x5b, 0x8c, 0x00, 0xd1, 0x3a, 0xb4, 0x09, 0xc0, 0x3c, 0x8d,
	0x5e, 0x43, 0x01, 0xc7, 0x07, 0x53, 0x52, 0xdd, 0x94, 0xc4, 0x15, 0x08, 0x6d, 0x42, 0xfe, 0x53,
	0xe8, 0x89, 0x20, 0x7e, 0xcd, 0x69, 0x57, 0xaf, 0xec, 0xcf, 0x06, 0xac, 0x26, 0x39, 0xa0, 0xb7,
	0xb0, 0x36, 0x10, 0xde, 0x47, 0xc6, 0xbb, 0x43, 0x1a, 0x30, 0x41, 0xd4, 0x76, 0xb9, 0xd6, 0xf6,
	0x74, 0x5c, 0xdd, 0xfa, 0xeb, 0xbd, 0xe9, 0x68, 0x5b, 0xdd, 0xd5, 0x18, 0x7f, 0xa8, 0xe0, 0x68,
	0x1b, 0x36, 0x94, 0x1e, 0x51, 0x3b, 0x8f, 0x72, 0x89, 0xfb, 0xf1, 0x11, 0x72, 0xee, 0xba, 0x8a,
	0x1f, 0xce, 0xc2, 0xf6, 0x77, 0x03, 0xac, 0xb6, 0xba, 0x77, 0xd7, 0x5e, 0xe5, 0x41, 0xd8, 0xff,
	0xbf, 0x07, 0xd8, 0x2f, 0x03, 0x40, 0x73, 0x5a, 0x9a, 0xcb, 0x3f, 0x9f, 0x61, 0x0b, 0x63, 0x29,
	0x7b, 0xab, 0xb1, 0x64, 0x73, 0x28, 0xb9, 0xf1, 0x18, 0xba, 0x2d, 0xed, 0x27, 0x00, 0x57, 0xb4,
	0x67, 0x6c, 0xd7, 0x26, 0xe3, 0x6a, 0x51, 0x37, 0xdc, 0xef, 0xcc, 0xf6, 0xdb, 0x27, 0xf6, 0x29,
	0x6c, 0x1e, 0x0d, 0x09, 0x96, 0x74, 0x61, 0xc2, 0x2c, 0xbd, 0xe9, 0x33, 0xc8, 0x0d, 0xb1, 0xf4,
	0x8e, 0xd5, 0x7e, 0x66, 0xb3, 0xbc, 0xf8, 0x58, 0x93, 0xad, 0xdd, 0xb8, 0xb0, 0x65, 0x9d, 0x4f,
	0x2a, 0xc6, 0xc5, 0xa4, 0x62, 0xfc, 0x9c, 0x54, 0x8c, 0x2f, 0x97, 0x95, 0xd4, 0xc5, 0x65, 0x25,
	0xf5, 0xe3, 0xb2, 0x92, 0xea, 0xe5, 0xd5, 0xcf, 0xf8, 0xf9, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x06, 0xbc, 0x67, 0x8a, 0xf4, 0x07, 0x00, 0x00,
}

func (m *DepositContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositContract) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n1, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ValidSince != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.ValidSince))
	}
	if m.ValidUntil != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.ValidUntil))
	}
	return i, nil
}

func (m *Deposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deposit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n2, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.DepositContractID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.DepositContractID)))
		i += copy(dAtA[i:], m.DepositContractID)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCodec(dAtA, i, uint64(m.Amount.Size()))
	n3, err := m.Amount.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintCodec(dAtA, i, uint64(m.Rate.Size()))
	n4, err := m.Rate.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.Depositor) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Depositor)))
		i += copy(dAtA[i:], m.Depositor)
	}
	if m.Released {
		dAtA[i] = 0x30
		i++
		if m.Released {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.CreatedAt))
	}
	return i, nil
}

func (m *Frac) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Frac) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Numerator != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Numerator))
	}
	if m.Denominator != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Denominator))
	}
	return i, nil
}

func (m *Configuration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Configuration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n5, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Owner) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Owner)))
		i += copy(dAtA[i:], m.Owner)
	}
	if len(m.Admin) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Admin)))
		i += copy(dAtA[i:], m.Admin)
	}
	if len(m.Bonuses) > 0 {
		for _, msg := range m.Bonuses {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCodec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BaseRates) > 0 {
		for _, msg := range m.BaseRates {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCodec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CustomRate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomRate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Qscore != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Qscore))))
		i += 4
	}
	return i, nil
}

func (m *DepositBonus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositBonus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LockinPeriod != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.LockinPeriod))
	}
	if m.BonusPercentage != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.BonusPercentage))
	}
	return i, nil
}

func (m *CreateDepositContractMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDepositContractMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n6, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.ValidSince != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.ValidSince))
	}
	if m.ValidUntil != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.ValidUntil))
	}
	return i, nil
}

func (m *DepositMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n7, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.DepositContractID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.DepositContractID)))
		i += copy(dAtA[i:], m.DepositContractID)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCodec(dAtA, i, uint64(m.Amount.Size()))
	n8, err := m.Amount.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.Depositor) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Depositor)))
		i += copy(dAtA[i:], m.Depositor)
	}
	return i, nil
}

func (m *ReleaseDepositMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReleaseDepositMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n9, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.DepositID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.DepositID)))
		i += copy(dAtA[i:], m.DepositID)
	}
	return i, nil
}

func (m *UpdateConfigurationMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateConfigurationMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n10, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Patch != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Patch.Size()))
		n11, err := m.Patch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func encodeVarintCodec(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DepositContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.ValidSince != 0 {
		n += 1 + sovCodec(uint64(m.ValidSince))
	}
	if m.ValidUntil != 0 {
		n += 1 + sovCodec(uint64(m.ValidUntil))
	}
	return n
}

func (m *Deposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.DepositContractID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCodec(uint64(l))
	l = m.Rate.Size()
	n += 1 + l + sovCodec(uint64(l))
	l = len(m.Depositor)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.Released {
		n += 2
	}
	if m.CreatedAt != 0 {
		n += 1 + sovCodec(uint64(m.CreatedAt))
	}
	return n
}

func (m *Frac) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Numerator != 0 {
		n += 1 + sovCodec(uint64(m.Numerator))
	}
	if m.Denominator != 0 {
		n += 1 + sovCodec(uint64(m.Denominator))
	}
	return n
}

func (m *Configuration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if len(m.Bonuses) > 0 {
		for _, e := range m.Bonuses {
			l = e.Size()
			n += 1 + l + sovCodec(uint64(l))
		}
	}
	if len(m.BaseRates) > 0 {
		for _, e := range m.BaseRates {
			l = e.Size()
			n += 1 + l + sovCodec(uint64(l))
		}
	}
	return n
}

func (m *CustomRate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.Qscore != 0 {
		n += 5
	}
	return n
}

func (m *DepositBonus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LockinPeriod != 0 {
		n += 1 + sovCodec(uint64(m.LockinPeriod))
	}
	if m.BonusPercentage != 0 {
		n += 1 + sovCodec(uint64(m.BonusPercentage))
	}
	return n
}

func (m *CreateDepositContractMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.ValidSince != 0 {
		n += 1 + sovCodec(uint64(m.ValidSince))
	}
	if m.ValidUntil != 0 {
		n += 1 + sovCodec(uint64(m.ValidUntil))
	}
	return n
}

func (m *DepositMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.DepositContractID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCodec(uint64(l))
	l = len(m.Depositor)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	return n
}

func (m *ReleaseDepositMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.DepositID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	return n
}

func (m *UpdateConfigurationMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.Patch != nil {
		l = m.Patch.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	return n
}

func sovCodec(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCodec(x uint64) (n int) {
	return sovCodec(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DepositContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidSince", wireType)
			}
			m.ValidSince = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidSince |= github_com_iov_one_weave.UnixTime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidUntil", wireType)
			}
			m.ValidUntil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidUntil |= github_com_iov_one_weave.UnixTime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositContractID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositContractID = append(m.DepositContractID[:0], dAtA[iNdEx:postIndex]...)
			if m.DepositContractID == nil {
				m.DepositContractID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Depositor = append(m.Depositor[:0], dAtA[iNdEx:postIndex]...)
			if m.Depositor == nil {
				m.Depositor = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Released", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Released = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= github_com_iov_one_weave.UnixTime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Frac) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Frac: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Frac: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Numerator", wireType)
			}
			m.Numerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Numerator |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denominator", wireType)
			}
			m.Denominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Denominator |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Configuration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Configuration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Configuration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bonuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bonuses = append(m.Bonuses, DepositBonus{})
			if err := m.Bonuses[len(m.Bonuses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseRates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseRates = append(m.BaseRates, CustomRate{})
			if err := m.BaseRates[len(m.BaseRates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomRate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomRate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomRate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qscore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Qscore = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositBonus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositBonus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositBonus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockinPeriod", wireType)
			}
			m.LockinPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockinPeriod |= github_com_iov_one_weave.UnixDuration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusPercentage", wireType)
			}
			m.BonusPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BonusPercentage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDepositContractMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDepositContractMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDepositContractMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidSince", wireType)
			}
			m.ValidSince = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidSince |= github_com_iov_one_weave.UnixTime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidUntil", wireType)
			}
			m.ValidUntil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidUntil |= github_com_iov_one_weave.UnixTime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositContractID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositContractID = append(m.DepositContractID[:0], dAtA[iNdEx:postIndex]...)
			if m.DepositContractID == nil {
				m.DepositContractID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Depositor = append(m.Depositor[:0], dAtA[iNdEx:postIndex]...)
			if m.Depositor == nil {
				m.Depositor = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReleaseDepositMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReleaseDepositMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReleaseDepositMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositID = append(m.DepositID[:0], dAtA[iNdEx:postIndex]...)
			if m.DepositID == nil {
				m.DepositID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateConfigurationMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateConfigurationMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateConfigurationMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Patch == nil {
				m.Patch = &Configuration{}
			}
			if err := m.Patch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCodec(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCodec
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCodec
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCodec
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCodec(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCodec
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCodec = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCodec   = fmt.Errorf("proto: integer overflow")
)
