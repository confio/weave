// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: x/gov/codec.proto

package gov

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	github_com_iov_one_weave "github.com/iov-one/weave"
	_ "github.com/iov-one/weave/coin"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Vote_VoteOption int32

const (
	Vote_ABSTAIN Vote_VoteOption = 0
	Vote_YES     Vote_VoteOption = 1
	Vote_NO      Vote_VoteOption = 2
)

var Vote_VoteOption_name = map[int32]string{
	0: "ABSTAIN",
	1: "YES",
	2: "NO",
}

var Vote_VoteOption_value = map[string]int32{
	"ABSTAIN": 0,
	"YES":     1,
	"NO":      2,
}

func (x Vote_VoteOption) String() string {
	return proto.EnumName(Vote_VoteOption_name, int32(x))
}

func (Vote_VoteOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{6, 0}
}

// Electorate defines who may vote in an election. This same group can be used in many elections
// and is stored for re-use
type Electorate struct {
	// Human readable title.
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// Participants defines a list of all signatures that are allowed to participate in a vote
	Participants []Participant `protobuf:"bytes,2,rep,name=participants,proto3" json:"participants"`
}

func (m *Electorate) Reset()         { *m = Electorate{} }
func (m *Electorate) String() string { return proto.CompactTextString(m) }
func (*Electorate) ProtoMessage()    {}
func (*Electorate) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{0}
}
func (m *Electorate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Electorate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Electorate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Electorate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Electorate.Merge(m, src)
}
func (m *Electorate) XXX_Size() int {
	return m.Size()
}
func (m *Electorate) XXX_DiscardUnknown() {
	xxx_messageInfo_Electorate.DiscardUnknown(m)
}

var xxx_messageInfo_Electorate proto.InternalMessageInfo

func (m *Electorate) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Electorate) GetParticipants() []Participant {
	if m != nil {
		return m.Participants
	}
	return nil
}

// Participant clubs together a signature with a weight. The greater the weight
// the greater the power of a participant.
type Participant struct {
	// The address of the voter.
	Signature github_com_iov_one_weave.Address `protobuf:"bytes,1,opt,name=signature,proto3,casttype=github.com/iov-one/weave.Address" json:"signature,omitempty"`
	// Weight defines the power of the participants vote. max value is 65535 (2^16-1).
	Weight uint32 `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *Participant) Reset()         { *m = Participant{} }
func (m *Participant) String() string { return proto.CompactTextString(m) }
func (*Participant) ProtoMessage()    {}
func (*Participant) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{1}
}
func (m *Participant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Participant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Participant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Participant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Participant.Merge(m, src)
}
func (m *Participant) XXX_Size() int {
	return m.Size()
}
func (m *Participant) XXX_DiscardUnknown() {
	xxx_messageInfo_Participant.DiscardUnknown(m)
}

var xxx_messageInfo_Participant proto.InternalMessageInfo

func (m *Participant) GetSignature() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Participant) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// Election Rules defines how an election is run. A proposal must be voted upon via a pre-defined ruleset.
type ElectionRules struct {
	// Human readable title.
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// Duration how long the voting period will take place.
	VotingPeriodHours uint32 `protobuf:"varint,3,opt,name=voting_period_hours,json=votingPeriodHours,proto3" json:"voting_period_hours,omitempty"`
	// Required Vote this is the percent value of all eligible voters, not the ones who voted.
	// (integer in steps of 0.01%, so 10000 is 100%. should disallow anything below 5001)
	RequiredVotes uint32 `protobuf:"varint,4,opt,name=required_votes,json=requiredVotes,proto3" json:"required_votes,omitempty"`
}

func (m *ElectionRules) Reset()         { *m = ElectionRules{} }
func (m *ElectionRules) String() string { return proto.CompactTextString(m) }
func (*ElectionRules) ProtoMessage()    {}
func (*ElectionRules) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{2}
}
func (m *ElectionRules) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElectionRules) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ElectionRules.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ElectionRules) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElectionRules.Merge(m, src)
}
func (m *ElectionRules) XXX_Size() int {
	return m.Size()
}
func (m *ElectionRules) XXX_DiscardUnknown() {
	xxx_messageInfo_ElectionRules.DiscardUnknown(m)
}

var xxx_messageInfo_ElectionRules proto.InternalMessageInfo

func (m *ElectionRules) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *ElectionRules) GetVotingPeriodHours() uint32 {
	if m != nil {
		return m.VotingPeriodHours
	}
	return 0
}

func (m *ElectionRules) GetRequiredVotes() uint32 {
	if m != nil {
		return m.RequiredVotes
	}
	return 0
}

// A text form proposal for an on-chain governance process.
type TextProposal struct {
	// Human readable title.
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// Description of the proposal in text form.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Reference to the election rules
	ElectionRulesId []byte `protobuf:"bytes,3,opt,name=election_rules_id,json=electionRulesId,proto3" json:"election_rules_id,omitempty"`
	// Reference to the electorate to define the group of possible voters.
	ElectorateId []byte `protobuf:"bytes,4,opt,name=electorate_id,json=electorateId,proto3" json:"electorate_id,omitempty"`
	// Unix timestamp of the block where the voting period starts. Header time of the votes must be greater than or equal
	// to this start time.
	VotingStartTime uint64 `protobuf:"varint,5,opt,name=voting_start_time,json=votingStartTime,proto3" json:"voting_start_time,omitempty"`
	// Unix timestamp of the block where the voting period ends. Header times of the votes must be before this end time
	// to be included in the election.
	VotingEndTime uint64 `protobuf:"varint,6,opt,name=voting_end_time,json=votingEndTime,proto3" json:"voting_end_time,omitempty"`
	// Unix timestamp of the block where the proposal was added to the chain.
	SubmissionTime uint64 `protobuf:"varint,7,opt,name=submission_time,json=submissionTime,proto3" json:"submission_time,omitempty"`
	// Main signer address who created the proposal.
	Author []byte `protobuf:"bytes,8,opt,name=author,proto3" json:"author,omitempty"`
	// Final result of the election.
	Result *TallyResult `protobuf:"bytes,9,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *TextProposal) Reset()         { *m = TextProposal{} }
func (m *TextProposal) String() string { return proto.CompactTextString(m) }
func (*TextProposal) ProtoMessage()    {}
func (*TextProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{3}
}
func (m *TextProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TextProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TextProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TextProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextProposal.Merge(m, src)
}
func (m *TextProposal) XXX_Size() int {
	return m.Size()
}
func (m *TextProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_TextProposal.DiscardUnknown(m)
}

var xxx_messageInfo_TextProposal proto.InternalMessageInfo

func (m *TextProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *TextProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TextProposal) GetElectionRulesId() []byte {
	if m != nil {
		return m.ElectionRulesId
	}
	return nil
}

func (m *TextProposal) GetElectorateId() []byte {
	if m != nil {
		return m.ElectorateId
	}
	return nil
}

func (m *TextProposal) GetVotingStartTime() uint64 {
	if m != nil {
		return m.VotingStartTime
	}
	return 0
}

func (m *TextProposal) GetVotingEndTime() uint64 {
	if m != nil {
		return m.VotingEndTime
	}
	return 0
}

func (m *TextProposal) GetSubmissionTime() uint64 {
	if m != nil {
		return m.SubmissionTime
	}
	return 0
}

func (m *TextProposal) GetAuthor() []byte {
	if m != nil {
		return m.Author
	}
	return nil
}

func (m *TextProposal) GetResult() *TallyResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// Result of a tally. Contains sums of the votes and the final result.
type TallyResult struct {
	// Sum of weights of all the voters that approved the proposal
	TotalYes uint32 `protobuf:"varint,1,opt,name=total_yes,json=totalYes,proto3" json:"total_yes,omitempty"`
	// Sum of weights of all the voters that rejected the proposal
	TotalNo uint32 `protobuf:"varint,2,opt,name=total_no,json=totalNo,proto3" json:"total_no,omitempty"`
	// Sum of weights of all the voters that voted abstain
	TotalAbstain uint32 `protobuf:"varint,3,opt,name=total_abstain,json=totalAbstain,proto3" json:"total_abstain,omitempty"`
	// Sum of all weights in the electorate.
	TotalWeightElectorate uint64 `protobuf:"varint,4,opt,name=total_weight_electorate,json=totalWeightElectorate,proto3" json:"total_weight_electorate,omitempty"`
	// Final result based on the votes and election rules.
	Passed bool `protobuf:"varint,5,opt,name=passed,proto3" json:"passed,omitempty"`
}

func (m *TallyResult) Reset()         { *m = TallyResult{} }
func (m *TallyResult) String() string { return proto.CompactTextString(m) }
func (*TallyResult) ProtoMessage()    {}
func (*TallyResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{4}
}
func (m *TallyResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TallyResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TallyResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TallyResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TallyResult.Merge(m, src)
}
func (m *TallyResult) XXX_Size() int {
	return m.Size()
}
func (m *TallyResult) XXX_DiscardUnknown() {
	xxx_messageInfo_TallyResult.DiscardUnknown(m)
}

var xxx_messageInfo_TallyResult proto.InternalMessageInfo

func (m *TallyResult) GetTotalYes() uint32 {
	if m != nil {
		return m.TotalYes
	}
	return 0
}

func (m *TallyResult) GetTotalNo() uint32 {
	if m != nil {
		return m.TotalNo
	}
	return 0
}

func (m *TallyResult) GetTotalAbstain() uint32 {
	if m != nil {
		return m.TotalAbstain
	}
	return 0
}

func (m *TallyResult) GetTotalWeightElectorate() uint64 {
	if m != nil {
		return m.TotalWeightElectorate
	}
	return 0
}

func (m *TallyResult) GetPassed() bool {
	if m != nil {
		return m.Passed
	}
	return false
}

// TBD
type CreateTextProposal struct {
	Title           string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description     string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	ElectionRulesId []byte `protobuf:"bytes,3,opt,name=election_rules_id,json=electionRulesId,proto3" json:"election_rules_id,omitempty"`
	ElectorateId    []byte `protobuf:"bytes,4,opt,name=electorate_id,json=electorateId,proto3" json:"electorate_id,omitempty"`
	// Unix timestamp....
	StartTime uint64 `protobuf:"varint,5,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
}

func (m *CreateTextProposal) Reset()         { *m = CreateTextProposal{} }
func (m *CreateTextProposal) String() string { return proto.CompactTextString(m) }
func (*CreateTextProposal) ProtoMessage()    {}
func (*CreateTextProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{5}
}
func (m *CreateTextProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateTextProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateTextProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateTextProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateTextProposal.Merge(m, src)
}
func (m *CreateTextProposal) XXX_Size() int {
	return m.Size()
}
func (m *CreateTextProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateTextProposal.DiscardUnknown(m)
}

var xxx_messageInfo_CreateTextProposal proto.InternalMessageInfo

func (m *CreateTextProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *CreateTextProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateTextProposal) GetElectionRulesId() []byte {
	if m != nil {
		return m.ElectionRulesId
	}
	return nil
}

func (m *CreateTextProposal) GetElectorateId() []byte {
	if m != nil {
		return m.ElectorateId
	}
	return nil
}

func (m *CreateTextProposal) GetStartTime() uint64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

// TBD
type Vote struct {
	ProposalId []byte                           `protobuf:"bytes,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	Voter      github_com_iov_one_weave.Address `protobuf:"bytes,2,opt,name=voter,proto3,casttype=github.com/iov-one/weave.Address" json:"voter,omitempty"`
	Selected   Vote_VoteOption                  `protobuf:"varint,3,opt,name=selected,proto3,enum=gov.Vote_VoteOption" json:"selected,omitempty"`
}

func (m *Vote) Reset()         { *m = Vote{} }
func (m *Vote) String() string { return proto.CompactTextString(m) }
func (*Vote) ProtoMessage()    {}
func (*Vote) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{6}
}
func (m *Vote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vote.Merge(m, src)
}
func (m *Vote) XXX_Size() int {
	return m.Size()
}
func (m *Vote) XXX_DiscardUnknown() {
	xxx_messageInfo_Vote.DiscardUnknown(m)
}

var xxx_messageInfo_Vote proto.InternalMessageInfo

func (m *Vote) GetProposalId() []byte {
	if m != nil {
		return m.ProposalId
	}
	return nil
}

func (m *Vote) GetVoter() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Voter
	}
	return nil
}

func (m *Vote) GetSelected() Vote_VoteOption {
	if m != nil {
		return m.Selected
	}
	return Vote_ABSTAIN
}

// TBD
type Tally struct {
	ProposalId []byte `protobuf:"bytes,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
}

func (m *Tally) Reset()         { *m = Tally{} }
func (m *Tally) String() string { return proto.CompactTextString(m) }
func (*Tally) ProtoMessage()    {}
func (*Tally) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{7}
}
func (m *Tally) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tally) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tally.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tally) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tally.Merge(m, src)
}
func (m *Tally) XXX_Size() int {
	return m.Size()
}
func (m *Tally) XXX_DiscardUnknown() {
	xxx_messageInfo_Tally.DiscardUnknown(m)
}

var xxx_messageInfo_Tally proto.InternalMessageInfo

func (m *Tally) GetProposalId() []byte {
	if m != nil {
		return m.ProposalId
	}
	return nil
}

func init() {
	proto.RegisterEnum("gov.Vote_VoteOption", Vote_VoteOption_name, Vote_VoteOption_value)
	proto.RegisterType((*Electorate)(nil), "gov.Electorate")
	proto.RegisterType((*Participant)(nil), "gov.Participant")
	proto.RegisterType((*ElectionRules)(nil), "gov.ElectionRules")
	proto.RegisterType((*TextProposal)(nil), "gov.TextProposal")
	proto.RegisterType((*TallyResult)(nil), "gov.TallyResult")
	proto.RegisterType((*CreateTextProposal)(nil), "gov.CreateTextProposal")
	proto.RegisterType((*Vote)(nil), "gov.Vote")
	proto.RegisterType((*Tally)(nil), "gov.Tally")
}

func init() { proto.RegisterFile("x/gov/codec.proto", fileDescriptor_24f6e3c5f1b82a85) }

var fileDescriptor_24f6e3c5f1b82a85 = []byte{
	// 727 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x54, 0x4d, 0x6f, 0xd3, 0x4a,
	0x14, 0x8d, 0xf3, 0x9d, 0x9b, 0xa4, 0x4d, 0xe7, 0xf5, 0xf5, 0xf9, 0xf5, 0xe9, 0x25, 0x91, 0xf9,
	0x0a, 0x95, 0x9a, 0xa0, 0x22, 0xb1, 0xe8, 0x2e, 0x41, 0x95, 0xc8, 0xa6, 0xad, 0xdc, 0x08, 0xd4,
	0x0d, 0x96, 0x13, 0x0f, 0xce, 0x48, 0x8e, 0xc7, 0xcc, 0x8c, 0xd3, 0x56, 0xe2, 0x47, 0xf0, 0x7b,
	0x10, 0x1b, 0x76, 0x5d, 0x76, 0x85, 0x58, 0x55, 0xa8, 0xfd, 0x17, 0xac, 0x90, 0xef, 0xb8, 0x4d,
	0x10, 0xaa, 0x60, 0xc9, 0x26, 0xf2, 0x3d, 0xe7, 0xf8, 0xce, 0x3d, 0xd7, 0x67, 0x02, 0x6b, 0xa7,
	0x3d, 0x9f, 0xcf, 0x7b, 0x13, 0xee, 0xd1, 0x49, 0x37, 0x12, 0x5c, 0x71, 0x92, 0xf3, 0xf9, 0x7c,
	0x73, 0xdb, 0x67, 0x6a, 0x1a, 0x8f, 0xbb, 0x13, 0x3e, 0xeb, 0xf9, 0xdc, 0xe7, 0x3d, 0xe4, 0xc6,
	0xf1, 0x1b, 0xac, 0xb0, 0xc0, 0x27, 0xfd, 0xce, 0xe6, 0xe3, 0x25, 0x39, 0xe3, 0xf3, 0x6d, 0x1e,
	0xd2, 0xde, 0x09, 0x75, 0xe7, 0xb4, 0x37, 0xe1, 0x2c, 0x5c, 0x6e, 0xbf, 0xd9, 0xf2, 0x39, 0xf7,
	0x03, 0xba, 0x68, 0xa8, 0xd8, 0x8c, 0x4a, 0xe5, 0xce, 0x22, 0x2d, 0xb0, 0x5e, 0x03, 0xec, 0x05,
	0x74, 0xa2, 0xb8, 0x70, 0x15, 0x25, 0xeb, 0x50, 0x50, 0x4c, 0x05, 0xd4, 0x34, 0xda, 0x46, 0xa7,
	0x62, 0xeb, 0x82, 0xec, 0x42, 0x2d, 0x72, 0x85, 0x62, 0x13, 0x16, 0xb9, 0xa1, 0x92, 0x66, 0xb6,
	0x9d, 0xeb, 0x54, 0x77, 0x1a, 0x5d, 0x9f, 0xcf, 0xbb, 0x87, 0x0b, 0x62, 0x90, 0x3f, 0xbf, 0x6c,
	0x65, 0xec, 0x1f, 0xb4, 0x16, 0x83, 0xea, 0x92, 0x84, 0x0c, 0xa0, 0x22, 0x99, 0x1f, 0xba, 0x2a,
	0x16, 0xfa, 0x90, 0xda, 0xe0, 0xfe, 0xb7, 0xcb, 0x56, 0xfb, 0x2e, 0x47, 0xdd, 0xbe, 0xe7, 0x09,
	0x2a, 0xa5, 0xbd, 0x78, 0x8d, 0x6c, 0x40, 0xf1, 0x84, 0x32, 0x7f, 0xaa, 0xcc, 0x6c, 0xdb, 0xe8,
	0xd4, 0xed, 0xb4, 0xb2, 0xde, 0x41, 0x1d, 0xad, 0x30, 0x1e, 0xda, 0x71, 0x40, 0xe5, 0x1d, 0x6e,
	0xba, 0xf0, 0xd7, 0x9c, 0x2b, 0x16, 0xfa, 0x4e, 0x44, 0x05, 0xe3, 0x9e, 0x33, 0xe5, 0xb1, 0x90,
	0x66, 0x0e, 0x7b, 0xad, 0x69, 0xea, 0x10, 0x99, 0x17, 0x09, 0x41, 0x1e, 0xc0, 0x8a, 0xa0, 0x6f,
	0x63, 0x26, 0xa8, 0xe7, 0xcc, 0xb9, 0xa2, 0xd2, 0xcc, 0xa3, 0xb4, 0x7e, 0x83, 0xbe, 0x4c, 0x40,
	0xeb, 0x73, 0x16, 0x6a, 0x23, 0x7a, 0xaa, 0x0e, 0x05, 0x8f, 0xb8, 0x74, 0x83, 0x3b, 0x4e, 0x6f,
	0x43, 0xd5, 0xa3, 0x72, 0x22, 0x58, 0x94, 0xcc, 0x89, 0x0e, 0x2a, 0xf6, 0x32, 0x44, 0xb6, 0x60,
	0x8d, 0xa6, 0x36, 0x1c, 0x91, 0xf8, 0x70, 0x98, 0x87, 0xd3, 0xd5, 0xec, 0x55, 0xba, 0xec, 0x6f,
	0xe8, 0x91, 0x7b, 0x50, 0xa7, 0xb7, 0x5f, 0x2f, 0xd1, 0xe5, 0x51, 0x57, 0x5b, 0x80, 0x43, 0x2f,
	0x69, 0x98, 0x1a, 0x96, 0xca, 0x15, 0xca, 0x49, 0x22, 0x60, 0x16, 0xda, 0x46, 0x27, 0x6f, 0xaf,
	0x6a, 0xe2, 0x28, 0xc1, 0x47, 0x6c, 0x46, 0xc9, 0x43, 0x48, 0x21, 0x87, 0x86, 0x9e, 0x56, 0x16,
	0x51, 0x59, 0xd7, 0xf0, 0x5e, 0xe8, 0xa1, 0xee, 0x11, 0xac, 0xca, 0x78, 0x3c, 0x63, 0x52, 0x26,
	0x63, 0xa2, 0xae, 0x84, 0xba, 0x95, 0x05, 0x8c, 0xc2, 0x0d, 0x28, 0xba, 0xb1, 0x9a, 0x72, 0x61,
	0x96, 0x71, 0xb4, 0xb4, 0x22, 0x1d, 0x28, 0x0a, 0x2a, 0xe3, 0x40, 0x99, 0x95, 0xb6, 0x71, 0x9b,
	0xa6, 0x91, 0x1b, 0x04, 0x67, 0x36, 0xe2, 0x76, 0xca, 0x5b, 0x1f, 0x0c, 0xa8, 0x2e, 0xe1, 0xe4,
	0x3f, 0xa8, 0x28, 0xae, 0xdc, 0xc0, 0x39, 0xa3, 0x12, 0x77, 0x5b, 0xb7, 0xcb, 0x08, 0x1c, 0x53,
	0x49, 0xfe, 0x05, 0xfd, 0xec, 0x84, 0x3c, 0x4d, 0x47, 0x09, 0xeb, 0x7d, 0x9e, 0xec, 0x4a, 0x53,
	0xee, 0x58, 0x2a, 0x97, 0x85, 0xe9, 0x17, 0xaf, 0x21, 0xd8, 0xd7, 0x18, 0x79, 0x06, 0xff, 0x68,
	0x91, 0xce, 0x94, 0xb3, 0x58, 0x24, 0xae, 0x36, 0x6f, 0xff, 0x8d, 0xf4, 0x2b, 0x64, 0x97, 0x2e,
	0xce, 0x06, 0x14, 0x23, 0x57, 0x4a, 0xea, 0xe1, 0x62, 0xcb, 0x76, 0x5a, 0x59, 0x1f, 0x0d, 0x20,
	0xcf, 0x05, 0x75, 0x15, 0xfd, 0x33, 0xb3, 0xf1, 0x3f, 0xc0, 0x4f, 0xa1, 0xa8, 0xc8, 0x9b, 0x38,
	0x58, 0x9f, 0x0c, 0xc8, 0x27, 0xf1, 0x26, 0x2d, 0xa8, 0x46, 0xe9, 0xf0, 0x49, 0x2b, 0xbc, 0xb9,
	0x36, 0xdc, 0x40, 0x43, 0x8f, 0xec, 0x42, 0x21, 0xb9, 0x1c, 0x02, 0xa7, 0xfe, 0xdd, 0x4b, 0xad,
	0x5f, 0x21, 0x4f, 0xa0, 0x2c, 0x71, 0x2a, 0xaa, 0xcd, 0xac, 0xec, 0xac, 0x63, 0x1a, 0x92, 0x93,
	0xf1, 0xe7, 0x00, 0xdd, 0xdb, 0xb7, 0x2a, 0x6b, 0x0b, 0x60, 0x81, 0x93, 0x2a, 0x94, 0xfa, 0x83,
	0xa3, 0x51, 0x7f, 0xb8, 0xdf, 0xc8, 0x90, 0x12, 0xe4, 0x8e, 0xf7, 0x8e, 0x1a, 0x06, 0x29, 0x42,
	0x76, 0xff, 0xa0, 0x91, 0xb5, 0x3a, 0x50, 0xc0, 0xf8, 0xfc, 0xd2, 0xc3, 0xc0, 0x3c, 0xbf, 0x6a,
	0x1a, 0x17, 0x57, 0x4d, 0xe3, 0xeb, 0x55, 0xd3, 0x78, 0x7f, 0xdd, 0xcc, 0x5c, 0x5c, 0x37, 0x33,
	0x5f, 0xae, 0x9b, 0x99, 0x71, 0x11, 0xff, 0x2c, 0x9f, 0x7e, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x68,
	0x2f, 0x98, 0x67, 0xc1, 0x05, 0x00, 0x00,
}

func (m *Electorate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Electorate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Participants) > 0 {
		for _, msg := range m.Participants {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCodec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Participant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Participant) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.Weight != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Weight))
	}
	return i, nil
}

func (m *ElectionRules) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElectionRules) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.VotingPeriodHours != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.VotingPeriodHours))
	}
	if m.RequiredVotes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.RequiredVotes))
	}
	return i, nil
}

func (m *TextProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextProposal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.ElectionRulesId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ElectionRulesId)))
		i += copy(dAtA[i:], m.ElectionRulesId)
	}
	if len(m.ElectorateId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ElectorateId)))
		i += copy(dAtA[i:], m.ElectorateId)
	}
	if m.VotingStartTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.VotingStartTime))
	}
	if m.VotingEndTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.VotingEndTime))
	}
	if m.SubmissionTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.SubmissionTime))
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if m.Result != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Result.Size()))
		n1, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *TallyResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TallyResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalYes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.TotalYes))
	}
	if m.TotalNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.TotalNo))
	}
	if m.TotalAbstain != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.TotalAbstain))
	}
	if m.TotalWeightElectorate != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.TotalWeightElectorate))
	}
	if m.Passed {
		dAtA[i] = 0x28
		i++
		if m.Passed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CreateTextProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTextProposal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.ElectionRulesId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ElectionRulesId)))
		i += copy(dAtA[i:], m.ElectionRulesId)
	}
	if len(m.ElectorateId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ElectorateId)))
		i += copy(dAtA[i:], m.ElectorateId)
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.StartTime))
	}
	return i, nil
}

func (m *Vote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProposalId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ProposalId)))
		i += copy(dAtA[i:], m.ProposalId)
	}
	if len(m.Voter) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Voter)))
		i += copy(dAtA[i:], m.Voter)
	}
	if m.Selected != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Selected))
	}
	return i, nil
}

func (m *Tally) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tally) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProposalId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ProposalId)))
		i += copy(dAtA[i:], m.ProposalId)
	}
	return i, nil
}

func encodeVarintCodec(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Electorate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if len(m.Participants) > 0 {
		for _, e := range m.Participants {
			l = e.Size()
			n += 1 + l + sovCodec(uint64(l))
		}
	}
	return n
}

func (m *Participant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovCodec(uint64(m.Weight))
	}
	return n
}

func (m *ElectionRules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.VotingPeriodHours != 0 {
		n += 1 + sovCodec(uint64(m.VotingPeriodHours))
	}
	if m.RequiredVotes != 0 {
		n += 1 + sovCodec(uint64(m.RequiredVotes))
	}
	return n
}

func (m *TextProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ElectionRulesId)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ElectorateId)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.VotingStartTime != 0 {
		n += 1 + sovCodec(uint64(m.VotingStartTime))
	}
	if m.VotingEndTime != 0 {
		n += 1 + sovCodec(uint64(m.VotingEndTime))
	}
	if m.SubmissionTime != 0 {
		n += 1 + sovCodec(uint64(m.SubmissionTime))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	return n
}

func (m *TallyResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalYes != 0 {
		n += 1 + sovCodec(uint64(m.TotalYes))
	}
	if m.TotalNo != 0 {
		n += 1 + sovCodec(uint64(m.TotalNo))
	}
	if m.TotalAbstain != 0 {
		n += 1 + sovCodec(uint64(m.TotalAbstain))
	}
	if m.TotalWeightElectorate != 0 {
		n += 1 + sovCodec(uint64(m.TotalWeightElectorate))
	}
	if m.Passed {
		n += 2
	}
	return n
}

func (m *CreateTextProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ElectionRulesId)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ElectorateId)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.StartTime != 0 {
		n += 1 + sovCodec(uint64(m.StartTime))
	}
	return n
}

func (m *Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProposalId)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.Selected != 0 {
		n += 1 + sovCodec(uint64(m.Selected))
	}
	return n
}

func (m *Tally) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProposalId)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	return n
}

func sovCodec(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCodec(x uint64) (n int) {
	return sovCodec(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Electorate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Electorate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Electorate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, Participant{})
			if err := m.Participants[len(m.Participants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Participant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Participant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Participant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ElectionRules) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElectionRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElectionRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPeriodHours", wireType)
			}
			m.VotingPeriodHours = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPeriodHours |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredVotes", wireType)
			}
			m.RequiredVotes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredVotes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectionRulesId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElectionRulesId = append(m.ElectionRulesId[:0], dAtA[iNdEx:postIndex]...)
			if m.ElectionRulesId == nil {
				m.ElectionRulesId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectorateId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElectorateId = append(m.ElectorateId[:0], dAtA[iNdEx:postIndex]...)
			if m.ElectorateId == nil {
				m.ElectorateId = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingStartTime", wireType)
			}
			m.VotingStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingStartTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingEndTime", wireType)
			}
			m.VotingEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingEndTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmissionTime", wireType)
			}
			m.SubmissionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmissionTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = append(m.Author[:0], dAtA[iNdEx:postIndex]...)
			if m.Author == nil {
				m.Author = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &TallyResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TallyResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TallyResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TallyResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalYes", wireType)
			}
			m.TotalYes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalYes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNo", wireType)
			}
			m.TotalNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNo |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAbstain", wireType)
			}
			m.TotalAbstain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAbstain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalWeightElectorate", wireType)
			}
			m.TotalWeightElectorate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalWeightElectorate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Passed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTextProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTextProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTextProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectionRulesId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElectionRulesId = append(m.ElectionRulesId[:0], dAtA[iNdEx:postIndex]...)
			if m.ElectionRulesId == nil {
				m.ElectionRulesId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectorateId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElectorateId = append(m.ElectorateId[:0], dAtA[iNdEx:postIndex]...)
			if m.ElectorateId == nil {
				m.ElectorateId = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposalId = append(m.ProposalId[:0], dAtA[iNdEx:postIndex]...)
			if m.ProposalId == nil {
				m.ProposalId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = append(m.Voter[:0], dAtA[iNdEx:postIndex]...)
			if m.Voter == nil {
				m.Voter = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selected", wireType)
			}
			m.Selected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Selected |= Vote_VoteOption(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tally) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tally: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tally: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposalId = append(m.ProposalId[:0], dAtA[iNdEx:postIndex]...)
			if m.ProposalId == nil {
				m.ProposalId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCodec(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCodec
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCodec
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCodec
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCodec(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCodec
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCodec = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCodec   = fmt.Errorf("proto: integer overflow")
)
