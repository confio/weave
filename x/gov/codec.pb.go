// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: x/gov/codec.proto

package gov

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_iov_one_weave "github.com/iov-one/weave"
	weave "github.com/iov-one/weave"
	orm "github.com/iov-one/weave/orm"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// VoteOptions define possible values for a vote including the INVALID default.
type VoteOption int32

const (
	VoteOption_Invalid VoteOption = 0
	VoteOption_Yes     VoteOption = 1
	VoteOption_No      VoteOption = 2
	VoteOption_Abstain VoteOption = 3
)

var VoteOption_name = map[int32]string{
	0: "VOTE_OPTION_INVALID",
	1: "VOTE_OPTION_YES",
	2: "VOTE_OPTION_NO",
	3: "VOTE_OPTION_ABSTAIN",
}

var VoteOption_value = map[string]int32{
	"VOTE_OPTION_INVALID": 0,
	"VOTE_OPTION_YES":     1,
	"VOTE_OPTION_NO":      2,
	"VOTE_OPTION_ABSTAIN": 3,
}

func (x VoteOption) String() string {
	return proto.EnumName(VoteOption_name, int32(x))
}

func (VoteOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{0}
}

type Proposal_Status int32

const (
	// An empty value is invalid and not allowed
	Proposal_Invalid Proposal_Status = 0
	// Initial status of a proposal when persisted.
	Proposal_Submitted Proposal_Status = 1
	// Final status of a proposal when the tally was executed
	Proposal_Closed Proposal_Status = 2
	// A proposal can be deleted before the voting start time by the owner. When this happens the final status
	// is Withdrawn.
	Proposal_Withdrawn Proposal_Status = 3
)

var Proposal_Status_name = map[int32]string{
	0: "PROPOSAL_STATUS_INVALID",
	1: "PROPOSAL_STATUS_SUBMITTED",
	2: "PROPOSAL_STATUS_CLOSED",
	3: "PROPOSAL_STATUS_WITHDRAWN",
}

var Proposal_Status_value = map[string]int32{
	"PROPOSAL_STATUS_INVALID":   0,
	"PROPOSAL_STATUS_SUBMITTED": 1,
	"PROPOSAL_STATUS_CLOSED":    2,
	"PROPOSAL_STATUS_WITHDRAWN": 3,
}

func (x Proposal_Status) String() string {
	return proto.EnumName(Proposal_Status_name, int32(x))
}

func (Proposal_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{6, 0}
}

type Proposal_Result int32

const (
	// An empty value is invalid and not allowed
	Proposal_Empty Proposal_Result = 0
	// Until a final tally has happened the status is undefined
	Proposal_Undefined Proposal_Result = 1
	// Final result of the tally
	Proposal_Accepted Proposal_Result = 2
	// Final result of the tally
	Proposal_Rejected Proposal_Result = 3
)

var Proposal_Result_name = map[int32]string{
	0: "PROPOSAL_RESULT_INVALID",
	1: "PROPOSAL_RESULT_UNDEFINED",
	2: "PROPOSAL_RESULT_ACCEPTED",
	3: "PROPOSAL_RESULT_REJECTED",
}

var Proposal_Result_value = map[string]int32{
	"PROPOSAL_RESULT_INVALID":   0,
	"PROPOSAL_RESULT_UNDEFINED": 1,
	"PROPOSAL_RESULT_ACCEPTED":  2,
	"PROPOSAL_RESULT_REJECTED":  3,
}

func (x Proposal_Result) String() string {
	return proto.EnumName(Proposal_Result_name, int32(x))
}

func (Proposal_Result) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{6, 1}
}

type Proposal_Type int32

const (
	// None is invalid and not allowed
	Proposal_None Proposal_Type = 0
	// Text
	Proposal_Text Proposal_Type = 1
	// UpdateElectorate
	Proposal_UpdateElectorate Proposal_Type = 2
)

var Proposal_Type_name = map[int32]string{
	0: "PROPOSAL_TYPE_INVALID",
	1: "PROPOSAL_TYPE_TEXT",
	2: "PROPOSAL_TYPE_UPDATE_ELECTORATE",
}

var Proposal_Type_value = map[string]int32{
	"PROPOSAL_TYPE_INVALID":           0,
	"PROPOSAL_TYPE_TEXT":              1,
	"PROPOSAL_TYPE_UPDATE_ELECTORATE": 2,
}

func (x Proposal_Type) String() string {
	return proto.EnumName(Proposal_Type_name, int32(x))
}

func (Proposal_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{6, 2}
}

// Electorate defines who may vote in an election. This same group can be used in many elections
// and is stored for re-use
type Electorate struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Document version
	Version uint32 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	// Admin is the address that is allowed ot modify an existing electorate.
	Admin github_com_iov_one_weave.Address `protobuf:"bytes,3,opt,name=admin,proto3,casttype=github.com/iov-one/weave.Address" json:"admin,omitempty"`
	// Human readable title.
	Title string `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	// Elector defines a list of all signatures that are allowed to participate in a vote
	Electors []Elector `protobuf:"bytes,5,rep,name=electors,proto3" json:"electors"`
	// TotalElectorateWeight is the sum of all electors weights.
	TotalElectorateWeight uint64 `protobuf:"varint,6,opt,name=total_electorate_weight,json=totalElectorateWeight,proto3" json:"total_electorate_weight,omitempty"`
	// UpdateElectionRuleID reference the rule to update this electorate.
	UpdateElectionRuleID []byte `protobuf:"bytes,7,opt,name=update_election_rule_id,json=updateElectionRuleId,proto3" json:"update_election_rule_id,omitempty"`
}

func (m *Electorate) Reset()         { *m = Electorate{} }
func (m *Electorate) String() string { return proto.CompactTextString(m) }
func (*Electorate) ProtoMessage()    {}
func (*Electorate) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{0}
}
func (m *Electorate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Electorate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Electorate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Electorate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Electorate.Merge(m, src)
}
func (m *Electorate) XXX_Size() int {
	return m.Size()
}
func (m *Electorate) XXX_DiscardUnknown() {
	xxx_messageInfo_Electorate.DiscardUnknown(m)
}

var xxx_messageInfo_Electorate proto.InternalMessageInfo

func (m *Electorate) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Electorate) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Electorate) GetAdmin() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *Electorate) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Electorate) GetElectors() []Elector {
	if m != nil {
		return m.Electors
	}
	return nil
}

func (m *Electorate) GetTotalElectorateWeight() uint64 {
	if m != nil {
		return m.TotalElectorateWeight
	}
	return 0
}

func (m *Electorate) GetUpdateElectionRuleID() []byte {
	if m != nil {
		return m.UpdateElectionRuleID
	}
	return nil
}

// Elector clubs together a address with a weight. The greater the weight
// the greater the power of a participant.
type Elector struct {
	// The address of the voter.
	Address github_com_iov_one_weave.Address `protobuf:"bytes,1,opt,name=address,proto3,casttype=github.com/iov-one/weave.Address" json:"address,omitempty"`
	// Weight defines the power of the participants vote. max value is 65535 (2^16-1).
	Weight uint32 `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *Elector) Reset()         { *m = Elector{} }
func (m *Elector) String() string { return proto.CompactTextString(m) }
func (*Elector) ProtoMessage()    {}
func (*Elector) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{1}
}
func (m *Elector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Elector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Elector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Elector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Elector.Merge(m, src)
}
func (m *Elector) XXX_Size() int {
	return m.Size()
}
func (m *Elector) XXX_DiscardUnknown() {
	xxx_messageInfo_Elector.DiscardUnknown(m)
}

var xxx_messageInfo_Elector proto.InternalMessageInfo

func (m *Elector) GetAddress() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Elector) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// Election Rule defines how an election is run. A proposal must be voted upon via a pre-defined ruleset.
type ElectionRule struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Admin is the address that is allowed ot modify an existing election rule.
	Admin github_com_iov_one_weave.Address `protobuf:"bytes,2,opt,name=admin,proto3,casttype=github.com/iov-one/weave.Address" json:"admin,omitempty"`
	// Human readable title.
	Title string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	// Duration how long the voting period will take place.
	VotingPeriodHours uint32 `protobuf:"varint,4,opt,name=voting_period_hours,json=votingPeriodHours,proto3" json:"voting_period_hours,omitempty"`
	// Threshold is the fraction of either all eligible voters or in case of a quorum setup the fraction of all non
	// abstained votes.
	// To accept a proposal this value must be exceeded with Yes votes.
	// The formula applied is:
	// (yes * denominator) > (base * numerator) with base total electorate weight or Yes/No votes in case of quorum set
	//
	// The valid range for the threshold value is `0.5` to `1` (inclusive) which allows any value between half and all
	// of the eligible voters.
	Threshold Fraction `protobuf:"bytes,5,opt,name=threshold,proto3" json:"threshold"`
	// The quorum fraction of eligible voters is based on the total electorate weight and defines a threshold of
	// votes that must be exceeded before the acceptance threshold is applied.
	// This value requires any kind of votes and not only YES.
	//
	// The valid range for the threshold value is `0.5` to `1` (inclusive) which allows any value between half and all
	// of the eligible voters.
	Quorum *Fraction `protobuf:"bytes,6,opt,name=quorum,proto3" json:"quorum,omitempty"`
}

func (m *ElectionRule) Reset()         { *m = ElectionRule{} }
func (m *ElectionRule) String() string { return proto.CompactTextString(m) }
func (*ElectionRule) ProtoMessage()    {}
func (*ElectionRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{2}
}
func (m *ElectionRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElectionRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ElectionRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ElectionRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElectionRule.Merge(m, src)
}
func (m *ElectionRule) XXX_Size() int {
	return m.Size()
}
func (m *ElectionRule) XXX_DiscardUnknown() {
	xxx_messageInfo_ElectionRule.DiscardUnknown(m)
}

var xxx_messageInfo_ElectionRule proto.InternalMessageInfo

func (m *ElectionRule) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ElectionRule) GetAdmin() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *ElectionRule) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *ElectionRule) GetVotingPeriodHours() uint32 {
	if m != nil {
		return m.VotingPeriodHours
	}
	return 0
}

func (m *ElectionRule) GetThreshold() Fraction {
	if m != nil {
		return m.Threshold
	}
	return Fraction{}
}

func (m *ElectionRule) GetQuorum() *Fraction {
	if m != nil {
		return m.Quorum
	}
	return nil
}

// The Fraction type represents a numerator and denominator to enable higher precision thresholds in
// the election rules. For example:
// numerator: 1, denominator: 2 => > 50%
// numerator: 2, denominator: 3 => > 66.666..%
// numerator: 6273, denominator: 10000 => > 62.73%
// Valid range of the fraction is 0.5 to 1.
type Fraction struct {
	// The top number in a fraction.
	Numerator uint32 `protobuf:"varint,1,opt,name=numerator,proto3" json:"numerator,omitempty"`
	// The bottom number
	Denominator uint32 `protobuf:"varint,2,opt,name=denominator,proto3" json:"denominator,omitempty"`
}

func (m *Fraction) Reset()         { *m = Fraction{} }
func (m *Fraction) String() string { return proto.CompactTextString(m) }
func (*Fraction) ProtoMessage()    {}
func (*Fraction) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{3}
}
func (m *Fraction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fraction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fraction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Fraction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fraction.Merge(m, src)
}
func (m *Fraction) XXX_Size() int {
	return m.Size()
}
func (m *Fraction) XXX_DiscardUnknown() {
	xxx_messageInfo_Fraction.DiscardUnknown(m)
}

var xxx_messageInfo_Fraction proto.InternalMessageInfo

func (m *Fraction) GetNumerator() uint32 {
	if m != nil {
		return m.Numerator
	}
	return 0
}

func (m *Fraction) GetDenominator() uint32 {
	if m != nil {
		return m.Denominator
	}
	return 0
}

// A text form proposal for an on-chain governance process.
type TextProposalPayload struct {
}

func (m *TextProposalPayload) Reset()         { *m = TextProposalPayload{} }
func (m *TextProposalPayload) String() string { return proto.CompactTextString(m) }
func (*TextProposalPayload) ProtoMessage()    {}
func (*TextProposalPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{4}
}
func (m *TextProposalPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TextProposalPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TextProposalPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TextProposalPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextProposalPayload.Merge(m, src)
}
func (m *TextProposalPayload) XXX_Size() int {
	return m.Size()
}
func (m *TextProposalPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_TextProposalPayload.DiscardUnknown(m)
}

var xxx_messageInfo_TextProposalPayload proto.InternalMessageInfo

type ElectorateUpdatePayload struct {
	// DiffElectors contains the changes that should be applied. Adding an address should have a positive weight, removing
	// with weight=0.
	DiffElectors []Elector `protobuf:"bytes,1,rep,name=diff_electors,json=diffElectors,proto3" json:"diff_electors"`
}

func (m *ElectorateUpdatePayload) Reset()         { *m = ElectorateUpdatePayload{} }
func (m *ElectorateUpdatePayload) String() string { return proto.CompactTextString(m) }
func (*ElectorateUpdatePayload) ProtoMessage()    {}
func (*ElectorateUpdatePayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{5}
}
func (m *ElectorateUpdatePayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElectorateUpdatePayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ElectorateUpdatePayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ElectorateUpdatePayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElectorateUpdatePayload.Merge(m, src)
}
func (m *ElectorateUpdatePayload) XXX_Size() int {
	return m.Size()
}
func (m *ElectorateUpdatePayload) XXX_DiscardUnknown() {
	xxx_messageInfo_ElectorateUpdatePayload.DiscardUnknown(m)
}

var xxx_messageInfo_ElectorateUpdatePayload proto.InternalMessageInfo

func (m *ElectorateUpdatePayload) GetDiffElectors() []Elector {
	if m != nil {
		return m.DiffElectors
	}
	return nil
}

// A generic proposal for an on-chain governance process.
type Proposal struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Human readable title.
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// Description of the proposal in text form.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Reference to the election rule
	ElectionRuleID []byte `protobuf:"bytes,4,opt,name=election_rule_id,json=electionRuleId,proto3" json:"election_rule_id,omitempty"`
	// Reference to the electorate to define the group of possible voters.
	ElectorateRef orm.VersionedIDRef `protobuf:"bytes,5,opt,name=electorate_ref,json=electorateRef,proto3" json:"electorate_ref"`
	// Unix timestamp of the block where the voting period starts. Header time of the votes must be greater than or equal
	// to this start time.
	VotingStartTime github_com_iov_one_weave.UnixTime `protobuf:"varint,6,opt,name=voting_start_time,json=votingStartTime,proto3,casttype=github.com/iov-one/weave.UnixTime" json:"voting_start_time,omitempty"`
	// Unix timestamp of the block where the voting period ends. Header times of the votes must be before this end time
	// to be included in the election.
	VotingEndTime github_com_iov_one_weave.UnixTime `protobuf:"varint,7,opt,name=voting_end_time,json=votingEndTime,proto3,casttype=github.com/iov-one/weave.UnixTime" json:"voting_end_time,omitempty"`
	// Unix timestamp of the block where the proposal was added to the chain.
	SubmissionTime github_com_iov_one_weave.UnixTime `protobuf:"varint,8,opt,name=submission_time,json=submissionTime,proto3,casttype=github.com/iov-one/weave.UnixTime" json:"submission_time,omitempty"`
	// Address of the author who created the proposal. If not set explicit on creation it will default to the main signer.
	Author github_com_iov_one_weave.Address `protobuf:"bytes,9,opt,name=author,proto3,casttype=github.com/iov-one/weave.Address" json:"author,omitempty"`
	// Result of the election. Contains intermediate tally results while voting period is open.
	VoteState TallyResult `protobuf:"bytes,10,opt,name=vote_state,json=voteState,proto3" json:"vote_state"`
	// Status represents the high level position in the life cycle of the proposal. Initial value is submitted.
	Status Proposal_Status `protobuf:"varint,11,opt,name=status,proto3,enum=gov.Proposal_Status" json:"status,omitempty"`
	// Result is the final result based on the votes and election rule. Initial value is Undefined.
	Result Proposal_Result `protobuf:"varint,12,opt,name=result,proto3,enum=gov.Proposal_Result" json:"result,omitempty"`
	Type   Proposal_Type   `protobuf:"varint,13,opt,name=type,proto3,enum=gov.Proposal_Type" json:"type,omitempty"`
	// details
	//
	// Types that are valid to be assigned to Details:
	//	*Proposal_TextDetails
	//	*Proposal_ElectorateUpdateDetails
	Details isProposal_Details `protobuf_oneof:"details"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}
func (*Proposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{6}
}
func (m *Proposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal.Merge(m, src)
}
func (m *Proposal) XXX_Size() int {
	return m.Size()
}
func (m *Proposal) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal proto.InternalMessageInfo

type isProposal_Details interface {
	isProposal_Details()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Proposal_TextDetails struct {
	TextDetails *TextProposalPayload `protobuf:"bytes,50,opt,name=text_details,json=textDetails,proto3,oneof"`
}
type Proposal_ElectorateUpdateDetails struct {
	ElectorateUpdateDetails *ElectorateUpdatePayload `protobuf:"bytes,51,opt,name=electorate_update_details,json=electorateUpdateDetails,proto3,oneof"`
}

func (*Proposal_TextDetails) isProposal_Details()             {}
func (*Proposal_ElectorateUpdateDetails) isProposal_Details() {}

func (m *Proposal) GetDetails() isProposal_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *Proposal) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Proposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Proposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Proposal) GetElectionRuleID() []byte {
	if m != nil {
		return m.ElectionRuleID
	}
	return nil
}

func (m *Proposal) GetElectorateRef() orm.VersionedIDRef {
	if m != nil {
		return m.ElectorateRef
	}
	return orm.VersionedIDRef{}
}

func (m *Proposal) GetVotingStartTime() github_com_iov_one_weave.UnixTime {
	if m != nil {
		return m.VotingStartTime
	}
	return 0
}

func (m *Proposal) GetVotingEndTime() github_com_iov_one_weave.UnixTime {
	if m != nil {
		return m.VotingEndTime
	}
	return 0
}

func (m *Proposal) GetSubmissionTime() github_com_iov_one_weave.UnixTime {
	if m != nil {
		return m.SubmissionTime
	}
	return 0
}

func (m *Proposal) GetAuthor() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Author
	}
	return nil
}

func (m *Proposal) GetVoteState() TallyResult {
	if m != nil {
		return m.VoteState
	}
	return TallyResult{}
}

func (m *Proposal) GetStatus() Proposal_Status {
	if m != nil {
		return m.Status
	}
	return Proposal_Invalid
}

func (m *Proposal) GetResult() Proposal_Result {
	if m != nil {
		return m.Result
	}
	return Proposal_Empty
}

func (m *Proposal) GetType() Proposal_Type {
	if m != nil {
		return m.Type
	}
	return Proposal_None
}

func (m *Proposal) GetTextDetails() *TextProposalPayload {
	if x, ok := m.GetDetails().(*Proposal_TextDetails); ok {
		return x.TextDetails
	}
	return nil
}

func (m *Proposal) GetElectorateUpdateDetails() *ElectorateUpdatePayload {
	if x, ok := m.GetDetails().(*Proposal_ElectorateUpdateDetails); ok {
		return x.ElectorateUpdateDetails
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Proposal) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Proposal_OneofMarshaler, _Proposal_OneofUnmarshaler, _Proposal_OneofSizer, []interface{}{
		(*Proposal_TextDetails)(nil),
		(*Proposal_ElectorateUpdateDetails)(nil),
	}
}

func _Proposal_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Proposal)
	// details
	switch x := m.Details.(type) {
	case *Proposal_TextDetails:
		_ = b.EncodeVarint(50<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TextDetails); err != nil {
			return err
		}
	case *Proposal_ElectorateUpdateDetails:
		_ = b.EncodeVarint(51<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ElectorateUpdateDetails); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Proposal.Details has unexpected type %T", x)
	}
	return nil
}

func _Proposal_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Proposal)
	switch tag {
	case 50: // details.text_details
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TextProposalPayload)
		err := b.DecodeMessage(msg)
		m.Details = &Proposal_TextDetails{msg}
		return true, err
	case 51: // details.electorate_update_details
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ElectorateUpdatePayload)
		err := b.DecodeMessage(msg)
		m.Details = &Proposal_ElectorateUpdateDetails{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Proposal_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Proposal)
	// details
	switch x := m.Details.(type) {
	case *Proposal_TextDetails:
		s := proto.Size(x.TextDetails)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Proposal_ElectorateUpdateDetails:
		s := proto.Size(x.ElectorateUpdateDetails)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// TallyResult contains sums of the votes and all data for the final result.
type TallyResult struct {
	// TotalYes is the sum of weights of all the voters that approved the proposal
	TotalYes uint64 `protobuf:"varint,1,opt,name=total_yes,json=totalYes,proto3" json:"total_yes,omitempty"`
	// TotalNo is the sum of weights of all the voters that rejected the proposal
	TotalNo uint64 `protobuf:"varint,2,opt,name=total_no,json=totalNo,proto3" json:"total_no,omitempty"`
	// TotalAbstain is the sum of weights of all the voters that voted abstain
	TotalAbstain uint64 `protobuf:"varint,3,opt,name=total_abstain,json=totalAbstain,proto3" json:"total_abstain,omitempty"`
	// TotalElectorateWeight is the sum of all weights in the electorate.
	TotalElectorateWeight uint64 `protobuf:"varint,4,opt,name=total_electorate_weight,json=totalElectorateWeight,proto3" json:"total_electorate_weight,omitempty"`
	// Quorum when set is the fraction of the total electorate weight that must be exceeded by total votes weight.
	Quorum *Fraction `protobuf:"bytes,5,opt,name=quorum,proto3" json:"quorum,omitempty"`
	// Threshold is the fraction of Yes votes of a base value that needs to be exceeded to accept the proposal.
	// The base value is either the total electorate weight or the sum of Yes/No weights when a quorum is defined.
	Threshold Fraction `protobuf:"bytes,6,opt,name=threshold,proto3" json:"threshold"`
}

func (m *TallyResult) Reset()         { *m = TallyResult{} }
func (m *TallyResult) String() string { return proto.CompactTextString(m) }
func (*TallyResult) ProtoMessage()    {}
func (*TallyResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{7}
}
func (m *TallyResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TallyResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TallyResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TallyResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TallyResult.Merge(m, src)
}
func (m *TallyResult) XXX_Size() int {
	return m.Size()
}
func (m *TallyResult) XXX_DiscardUnknown() {
	xxx_messageInfo_TallyResult.DiscardUnknown(m)
}

var xxx_messageInfo_TallyResult proto.InternalMessageInfo

func (m *TallyResult) GetTotalYes() uint64 {
	if m != nil {
		return m.TotalYes
	}
	return 0
}

func (m *TallyResult) GetTotalNo() uint64 {
	if m != nil {
		return m.TotalNo
	}
	return 0
}

func (m *TallyResult) GetTotalAbstain() uint64 {
	if m != nil {
		return m.TotalAbstain
	}
	return 0
}

func (m *TallyResult) GetTotalElectorateWeight() uint64 {
	if m != nil {
		return m.TotalElectorateWeight
	}
	return 0
}

func (m *TallyResult) GetQuorum() *Fraction {
	if m != nil {
		return m.Quorum
	}
	return nil
}

func (m *TallyResult) GetThreshold() Fraction {
	if m != nil {
		return m.Threshold
	}
	return Fraction{}
}

// Vote combines the elector and their voted option to archive them. The proposalID and address is stored within the key.
type Vote struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Elector is who voted
	Elector Elector `protobuf:"bytes,2,opt,name=elector,proto3" json:"elector"`
	// VoteOption is what they voted
	Voted VoteOption `protobuf:"varint,3,opt,name=voted,proto3,enum=gov.VoteOption" json:"voted,omitempty"`
}

func (m *Vote) Reset()         { *m = Vote{} }
func (m *Vote) String() string { return proto.CompactTextString(m) }
func (*Vote) ProtoMessage()    {}
func (*Vote) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{8}
}
func (m *Vote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vote.Merge(m, src)
}
func (m *Vote) XXX_Size() int {
	return m.Size()
}
func (m *Vote) XXX_DiscardUnknown() {
	xxx_messageInfo_Vote.DiscardUnknown(m)
}

var xxx_messageInfo_Vote proto.InternalMessageInfo

func (m *Vote) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Vote) GetElector() Elector {
	if m != nil {
		return m.Elector
	}
	return Elector{}
}

func (m *Vote) GetVoted() VoteOption {
	if m != nil {
		return m.Voted
	}
	return VoteOption_Invalid
}

// CreateTextProposalMsg creates a new governance proposal.
type CreateTextProposalMsg struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Human readable title. Must match `^[a-zA-Z0-9 _.-]{4,128}$`
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// Human readable description with 3 to 5000 chars.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// ElectionRuleID is a reference to the election rule
	ElectionRuleID []byte `protobuf:"bytes,4,opt,name=election_rule_id,json=electionRuleId,proto3" json:"election_rule_id,omitempty"`
	// ElectorateID is the reference to the electorate to define the group of possible voters.
	ElectorateID []byte `protobuf:"bytes,5,opt,name=electorate_id,json=electorateId,proto3" json:"electorate_id,omitempty"`
	// Unix timestamp when the proposal starts. Must be in the future.
	StartTime github_com_iov_one_weave.UnixTime `protobuf:"varint,6,opt,name=start_time,json=startTime,proto3,casttype=github.com/iov-one/weave.UnixTime" json:"start_time,omitempty"`
	// Author is an optional field to set the address of the author with a proposal. The author must sign the message.
	// When not set it will default to the main signer.
	Author github_com_iov_one_weave.Address `protobuf:"bytes,7,opt,name=author,proto3,casttype=github.com/iov-one/weave.Address" json:"author,omitempty"`
}

func (m *CreateTextProposalMsg) Reset()         { *m = CreateTextProposalMsg{} }
func (m *CreateTextProposalMsg) String() string { return proto.CompactTextString(m) }
func (*CreateTextProposalMsg) ProtoMessage()    {}
func (*CreateTextProposalMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{9}
}
func (m *CreateTextProposalMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateTextProposalMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateTextProposalMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateTextProposalMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateTextProposalMsg.Merge(m, src)
}
func (m *CreateTextProposalMsg) XXX_Size() int {
	return m.Size()
}
func (m *CreateTextProposalMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateTextProposalMsg.DiscardUnknown(m)
}

var xxx_messageInfo_CreateTextProposalMsg proto.InternalMessageInfo

func (m *CreateTextProposalMsg) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreateTextProposalMsg) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *CreateTextProposalMsg) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateTextProposalMsg) GetElectionRuleID() []byte {
	if m != nil {
		return m.ElectionRuleID
	}
	return nil
}

func (m *CreateTextProposalMsg) GetElectorateID() []byte {
	if m != nil {
		return m.ElectorateID
	}
	return nil
}

func (m *CreateTextProposalMsg) GetStartTime() github_com_iov_one_weave.UnixTime {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *CreateTextProposalMsg) GetAuthor() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Author
	}
	return nil
}

// CreateElectorateUpdateProposalMsg creates a new governance proposal to update an electorate.
type CreateElectorateUpdateProposalMsg struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Human readable title. Must match `^[a-zA-Z0-9 _.-]{4,128}$`
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// Human readable description with 3 to 5000 chars.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// ElectorateID is the reference to the electorate that defines the group of possible voters.
	ElectorateID []byte `protobuf:"bytes,4,opt,name=electorate_id,json=electorateId,proto3" json:"electorate_id,omitempty"`
	// Unix timestamp when the proposal starts. Must be in the future.
	StartTime github_com_iov_one_weave.UnixTime `protobuf:"varint,5,opt,name=start_time,json=startTime,proto3,casttype=github.com/iov-one/weave.UnixTime" json:"start_time,omitempty"`
	// Author is an optional field to set the address of the author with a proposal. The author must sign the message.
	// When not set it will default to the main signer.
	Author github_com_iov_one_weave.Address `protobuf:"bytes,6,opt,name=author,proto3,casttype=github.com/iov-one/weave.Address" json:"author,omitempty"`
	// DiffElectors contains the changes that should be applied. Adding an address should have a positive weight, removing
	// with weight=0.
	DiffElectors []Elector `protobuf:"bytes,7,rep,name=diff_electors,json=diffElectors,proto3" json:"diff_electors"`
}

func (m *CreateElectorateUpdateProposalMsg) Reset()         { *m = CreateElectorateUpdateProposalMsg{} }
func (m *CreateElectorateUpdateProposalMsg) String() string { return proto.CompactTextString(m) }
func (*CreateElectorateUpdateProposalMsg) ProtoMessage()    {}
func (*CreateElectorateUpdateProposalMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{10}
}
func (m *CreateElectorateUpdateProposalMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateElectorateUpdateProposalMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateElectorateUpdateProposalMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateElectorateUpdateProposalMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateElectorateUpdateProposalMsg.Merge(m, src)
}
func (m *CreateElectorateUpdateProposalMsg) XXX_Size() int {
	return m.Size()
}
func (m *CreateElectorateUpdateProposalMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateElectorateUpdateProposalMsg.DiscardUnknown(m)
}

var xxx_messageInfo_CreateElectorateUpdateProposalMsg proto.InternalMessageInfo

func (m *CreateElectorateUpdateProposalMsg) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreateElectorateUpdateProposalMsg) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *CreateElectorateUpdateProposalMsg) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateElectorateUpdateProposalMsg) GetElectorateID() []byte {
	if m != nil {
		return m.ElectorateID
	}
	return nil
}

func (m *CreateElectorateUpdateProposalMsg) GetStartTime() github_com_iov_one_weave.UnixTime {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *CreateElectorateUpdateProposalMsg) GetAuthor() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Author
	}
	return nil
}

func (m *CreateElectorateUpdateProposalMsg) GetDiffElectors() []Elector {
	if m != nil {
		return m.DiffElectors
	}
	return nil
}

// DeleteProposalMsg deletes a governance proposal.
type DeleteProposalMsg struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// ID is the unique identifier of the proposal to delete
	ID []byte `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *DeleteProposalMsg) Reset()         { *m = DeleteProposalMsg{} }
func (m *DeleteProposalMsg) String() string { return proto.CompactTextString(m) }
func (*DeleteProposalMsg) ProtoMessage()    {}
func (*DeleteProposalMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{11}
}
func (m *DeleteProposalMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteProposalMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteProposalMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteProposalMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteProposalMsg.Merge(m, src)
}
func (m *DeleteProposalMsg) XXX_Size() int {
	return m.Size()
}
func (m *DeleteProposalMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteProposalMsg.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteProposalMsg proto.InternalMessageInfo

func (m *DeleteProposalMsg) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DeleteProposalMsg) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

// VoteMsg is the way to express a voice and participate in an election of a proposal on chain.
type VoteMsg struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// The unique id of the proposal.
	ProposalID []byte `protobuf:"bytes,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// voter address is an optional field. When not set the main signer will be used as default. The voter address
	// must be included in the electorate for a valid vote.
	Voter github_com_iov_one_weave.Address `protobuf:"bytes,3,opt,name=voter,proto3,casttype=github.com/iov-one/weave.Address" json:"voter,omitempty"`
	// Option for the vote. Must be Yes, No or Abstain for a valid vote.
	Selected VoteOption `protobuf:"varint,4,opt,name=selected,proto3,enum=gov.VoteOption" json:"selected,omitempty"`
}

func (m *VoteMsg) Reset()         { *m = VoteMsg{} }
func (m *VoteMsg) String() string { return proto.CompactTextString(m) }
func (*VoteMsg) ProtoMessage()    {}
func (*VoteMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{12}
}
func (m *VoteMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteMsg.Merge(m, src)
}
func (m *VoteMsg) XXX_Size() int {
	return m.Size()
}
func (m *VoteMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteMsg.DiscardUnknown(m)
}

var xxx_messageInfo_VoteMsg proto.InternalMessageInfo

func (m *VoteMsg) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *VoteMsg) GetProposalID() []byte {
	if m != nil {
		return m.ProposalID
	}
	return nil
}

func (m *VoteMsg) GetVoter() github_com_iov_one_weave.Address {
	if m != nil {
		return m.Voter
	}
	return nil
}

func (m *VoteMsg) GetSelected() VoteOption {
	if m != nil {
		return m.Selected
	}
	return VoteOption_Invalid
}

// TallyMsg can be sent after the voting period has ended to do the final tally and trigger any state changes.
// A final tally can be execute only once. A second submission will fail with an invalid state error.
type TallyMsg struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// ProposalID is UUID of the proposal to close.
	ProposalID []byte `protobuf:"bytes,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
}

func (m *TallyMsg) Reset()         { *m = TallyMsg{} }
func (m *TallyMsg) String() string { return proto.CompactTextString(m) }
func (*TallyMsg) ProtoMessage()    {}
func (*TallyMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{13}
}
func (m *TallyMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TallyMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TallyMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TallyMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TallyMsg.Merge(m, src)
}
func (m *TallyMsg) XXX_Size() int {
	return m.Size()
}
func (m *TallyMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_TallyMsg.DiscardUnknown(m)
}

var xxx_messageInfo_TallyMsg proto.InternalMessageInfo

func (m *TallyMsg) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *TallyMsg) GetProposalID() []byte {
	if m != nil {
		return m.ProposalID
	}
	return nil
}

type UpdateElectorateMsg struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// ElectorateID is the reference to the electorate that defines the group of possible voters.
	ElectorateID []byte `protobuf:"bytes,2,opt,name=electorate_id,json=electorateId,proto3" json:"electorate_id,omitempty"`
	// DiffElectors contains the changes that should be applied. Adding an address should have a positive weight, removing
	// with weight=0.
	DiffElectors []Elector `protobuf:"bytes,3,rep,name=diff_electors,json=diffElectors,proto3" json:"diff_electors"`
}

func (m *UpdateElectorateMsg) Reset()         { *m = UpdateElectorateMsg{} }
func (m *UpdateElectorateMsg) String() string { return proto.CompactTextString(m) }
func (*UpdateElectorateMsg) ProtoMessage()    {}
func (*UpdateElectorateMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{14}
}
func (m *UpdateElectorateMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateElectorateMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateElectorateMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateElectorateMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateElectorateMsg.Merge(m, src)
}
func (m *UpdateElectorateMsg) XXX_Size() int {
	return m.Size()
}
func (m *UpdateElectorateMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateElectorateMsg.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateElectorateMsg proto.InternalMessageInfo

func (m *UpdateElectorateMsg) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *UpdateElectorateMsg) GetElectorateID() []byte {
	if m != nil {
		return m.ElectorateID
	}
	return nil
}

func (m *UpdateElectorateMsg) GetDiffElectors() []Elector {
	if m != nil {
		return m.DiffElectors
	}
	return nil
}

type UpdateElectionRuleMsg struct {
	Metadata *weave.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// ElectionRuleID is a reference to the election rule
	ElectionRuleID []byte `protobuf:"bytes,2,opt,name=election_rule_id,json=electionRuleId,proto3" json:"election_rule_id,omitempty"`
	// Duration how long the voting period will take place.
	VotingPeriodHours uint32 `protobuf:"varint,3,opt,name=voting_period_hours,json=votingPeriodHours,proto3" json:"voting_period_hours,omitempty"`
	// Threshold is the fraction of all eligible voters, not only the ones who voted. To accept a
	// proposal this value must be exceeded.
	// The formula is `(yes*denominator) > (numerator*total_electors_weight)`.
	// The valid range for the threshold value is `0.5` to `1` (inclusive) which allows any value between half and all
	// of the eligible voters.
	Threshold Fraction `protobuf:"bytes,4,opt,name=threshold,proto3" json:"threshold"`
}

func (m *UpdateElectionRuleMsg) Reset()         { *m = UpdateElectionRuleMsg{} }
func (m *UpdateElectionRuleMsg) String() string { return proto.CompactTextString(m) }
func (*UpdateElectionRuleMsg) ProtoMessage()    {}
func (*UpdateElectionRuleMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_24f6e3c5f1b82a85, []int{15}
}
func (m *UpdateElectionRuleMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateElectionRuleMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateElectionRuleMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateElectionRuleMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateElectionRuleMsg.Merge(m, src)
}
func (m *UpdateElectionRuleMsg) XXX_Size() int {
	return m.Size()
}
func (m *UpdateElectionRuleMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateElectionRuleMsg.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateElectionRuleMsg proto.InternalMessageInfo

func (m *UpdateElectionRuleMsg) GetMetadata() *weave.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *UpdateElectionRuleMsg) GetElectionRuleID() []byte {
	if m != nil {
		return m.ElectionRuleID
	}
	return nil
}

func (m *UpdateElectionRuleMsg) GetVotingPeriodHours() uint32 {
	if m != nil {
		return m.VotingPeriodHours
	}
	return 0
}

func (m *UpdateElectionRuleMsg) GetThreshold() Fraction {
	if m != nil {
		return m.Threshold
	}
	return Fraction{}
}

func init() {
	proto.RegisterEnum("gov.VoteOption", VoteOption_name, VoteOption_value)
	proto.RegisterEnum("gov.Proposal_Status", Proposal_Status_name, Proposal_Status_value)
	proto.RegisterEnum("gov.Proposal_Result", Proposal_Result_name, Proposal_Result_value)
	proto.RegisterEnum("gov.Proposal_Type", Proposal_Type_name, Proposal_Type_value)
	proto.RegisterType((*Electorate)(nil), "gov.Electorate")
	proto.RegisterType((*Elector)(nil), "gov.Elector")
	proto.RegisterType((*ElectionRule)(nil), "gov.ElectionRule")
	proto.RegisterType((*Fraction)(nil), "gov.Fraction")
	proto.RegisterType((*TextProposalPayload)(nil), "gov.TextProposalPayload")
	proto.RegisterType((*ElectorateUpdatePayload)(nil), "gov.ElectorateUpdatePayload")
	proto.RegisterType((*Proposal)(nil), "gov.Proposal")
	proto.RegisterType((*TallyResult)(nil), "gov.TallyResult")
	proto.RegisterType((*Vote)(nil), "gov.Vote")
	proto.RegisterType((*CreateTextProposalMsg)(nil), "gov.CreateTextProposalMsg")
	proto.RegisterType((*CreateElectorateUpdateProposalMsg)(nil), "gov.CreateElectorateUpdateProposalMsg")
	proto.RegisterType((*DeleteProposalMsg)(nil), "gov.DeleteProposalMsg")
	proto.RegisterType((*VoteMsg)(nil), "gov.VoteMsg")
	proto.RegisterType((*TallyMsg)(nil), "gov.TallyMsg")
	proto.RegisterType((*UpdateElectorateMsg)(nil), "gov.UpdateElectorateMsg")
	proto.RegisterType((*UpdateElectionRuleMsg)(nil), "gov.UpdateElectionRuleMsg")
}

func init() { proto.RegisterFile("x/gov/codec.proto", fileDescriptor_24f6e3c5f1b82a85) }

var fileDescriptor_24f6e3c5f1b82a85 = []byte{
	// 1584 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0x4f, 0x8f, 0x1a, 0xc9,
	0x15, 0x9f, 0x6e, 0xfe, 0x3f, 0xfe, 0x0c, 0xae, 0x99, 0xf1, 0xb4, 0x89, 0x35, 0xf4, 0xb2, 0xf6,
	0x0a, 0x6d, 0xbc, 0x8c, 0x32, 0xab, 0x4d, 0x94, 0x68, 0x13, 0x09, 0x86, 0x5e, 0x99, 0xd5, 0x18,
	0xd8, 0xa2, 0xb1, 0xd7, 0xb9, 0xb4, 0x7a, 0xe8, 0x1a, 0xe8, 0x08, 0xba, 0x48, 0x77, 0x81, 0x3d,
	0xdf, 0x20, 0xe2, 0x10, 0x45, 0xb9, 0xe4, 0xc4, 0x97, 0xc8, 0x21, 0x9f, 0x61, 0x8f, 0x3e, 0xe6,
	0x84, 0x22, 0xac, 0x7c, 0x84, 0x5c, 0x56, 0x3e, 0x44, 0x5d, 0xdd, 0x40, 0x0f, 0xcc, 0x58, 0x60,
	0x2b, 0x91, 0xf6, 0x46, 0xbd, 0xf7, 0x7b, 0xaf, 0x5e, 0xbd, 0xf7, 0xab, 0xf7, 0xaa, 0x81, 0x7b,
	0xaf, 0x4f, 0xbb, 0x74, 0x7c, 0xda, 0xa1, 0x06, 0xe9, 0x94, 0x86, 0x36, 0x65, 0x14, 0x85, 0xba,
	0x74, 0x9c, 0xfb, 0xa2, 0x6b, 0xb2, 0xde, 0xe8, 0xb2, 0xd4, 0xa1, 0x83, 0xd3, 0x2e, 0xed, 0xd2,
	0x53, 0xae, 0xbb, 0x1c, 0x5d, 0xf1, 0x15, 0x5f, 0xf0, 0x5f, 0x9e, 0x4d, 0xee, 0x51, 0x00, 0x6e,
	0xd2, 0xf1, 0x17, 0xd4, 0x22, 0xa7, 0xaf, 0x88, 0x3e, 0x26, 0x41, 0xcf, 0xb9, 0xe2, 0x9d, 0x28,
	0x6a, 0x0f, 0x82, 0xc8, 0xc2, 0x4c, 0x04, 0x50, 0xfa, 0xa4, 0xc3, 0xa8, 0xad, 0x33, 0x82, 0x7e,
	0x0e, 0xf1, 0x01, 0x61, 0xba, 0xa1, 0x33, 0x5d, 0x12, 0x64, 0xa1, 0x98, 0x3c, 0xdb, 0x2f, 0x71,
	0xc3, 0xd2, 0x33, 0x5f, 0x8c, 0x97, 0x00, 0x24, 0x41, 0x6c, 0x4c, 0x6c, 0xc7, 0xa4, 0x96, 0x24,
	0xca, 0x42, 0x31, 0x8d, 0x17, 0x4b, 0xf4, 0x1b, 0x88, 0xe8, 0xc6, 0xc0, 0xb4, 0xa4, 0x90, 0x2c,
	0x14, 0x53, 0x95, 0x47, 0x3f, 0xce, 0xf2, 0xf2, 0x5d, 0x21, 0x95, 0xca, 0x86, 0x61, 0x13, 0xc7,
	0xc1, 0x9e, 0x09, 0x3a, 0x84, 0x08, 0x33, 0x59, 0x9f, 0x48, 0x61, 0x59, 0x28, 0x26, 0xb0, 0xb7,
	0x40, 0x25, 0x88, 0x13, 0x2f, 0x4c, 0x47, 0x8a, 0xc8, 0xa1, 0x62, 0xf2, 0x2c, 0x55, 0xea, 0xd2,
	0x71, 0xc9, 0x8f, 0xbd, 0x12, 0xfe, 0x61, 0x96, 0xdf, 0xc3, 0x4b, 0x0c, 0xfa, 0x25, 0x1c, 0x33,
	0xca, 0xf4, 0xbe, 0x46, 0x96, 0x87, 0xd3, 0x5e, 0x11, 0xb3, 0xdb, 0x63, 0x52, 0x54, 0x16, 0x8a,
	0x61, 0x7c, 0xc4, 0xd5, 0xab, 0xa3, 0xbf, 0xe0, 0x4a, 0xd4, 0x80, 0xe3, 0xd1, 0xd0, 0x70, 0xd1,
	0xdc, 0xd0, 0xa4, 0x96, 0x66, 0x8f, 0xfa, 0x44, 0x33, 0x0d, 0x29, 0xc6, 0xcf, 0x22, 0xcd, 0x67,
	0xf9, 0xc3, 0x36, 0x87, 0x28, 0x3e, 0x02, 0x8f, 0xfa, 0xa4, 0x56, 0xc5, 0x87, 0xa3, 0x4d, 0xa9,
	0x51, 0xd0, 0x21, 0xe6, 0x6f, 0x82, 0x7e, 0x07, 0x31, 0xdd, 0x3b, 0x2b, 0xcf, 0xed, 0xb6, 0x79,
	0x59, 0x18, 0xa1, 0xfb, 0x10, 0xf5, 0x8f, 0xe0, 0xa5, 0xdb, 0x5f, 0x15, 0xfe, 0x26, 0x42, 0x2a,
	0xb8, 0xeb, 0x6e, 0x55, 0x5c, 0xd6, 0x4a, 0xfc, 0x88, 0x5a, 0x85, 0x6e, 0xd6, 0xea, 0x60, 0x4c,
	0x99, 0x69, 0x75, 0xb5, 0x21, 0xb1, 0x4d, 0x6a, 0x68, 0x3d, 0x3a, 0xb2, 0x1d, 0x5e, 0xcf, 0x34,
	0xbe, 0xe7, 0xa9, 0x9a, 0x5c, 0xf3, 0xd4, 0x55, 0xa0, 0x5f, 0x40, 0x82, 0xf5, 0x6c, 0xe2, 0xf4,
	0x68, 0xdf, 0x90, 0x22, 0x3c, 0xde, 0x34, 0x2f, 0xee, 0x37, 0xb6, 0xce, 0x0f, 0xe5, 0x57, 0x77,
	0x85, 0x42, 0x8f, 0x21, 0xfa, 0xc7, 0x11, 0xb5, 0x47, 0x03, 0x5e, 0xcd, 0x75, 0x3c, 0xf6, 0x95,
	0x85, 0x6f, 0x21, 0xbe, 0x90, 0xa1, 0x87, 0x90, 0xb0, 0x46, 0x03, 0x62, 0xeb, 0x8c, 0xda, 0x3c,
	0x2b, 0x69, 0xbc, 0x12, 0x20, 0x19, 0x92, 0x06, 0xb1, 0xe8, 0xc0, 0xb4, 0xb8, 0xde, 0x4b, 0x70,
	0x50, 0x54, 0x38, 0x82, 0x03, 0x95, 0xbc, 0x66, 0x4d, 0x9b, 0x0e, 0xa9, 0xa3, 0xf7, 0x9b, 0xfa,
	0x75, 0x9f, 0xea, 0x46, 0x01, 0xc3, 0xf1, 0x8a, 0x44, 0x1e, 0x2f, 0x7c, 0x15, 0xfa, 0x15, 0xa4,
	0x0d, 0xf3, 0xea, 0x4a, 0x5b, 0x12, 0x57, 0xb8, 0x93, 0xb8, 0x29, 0x17, 0xe8, 0x8b, 0x9c, 0xc2,
	0x9f, 0x93, 0x10, 0x5f, 0xec, 0xb3, 0x5b, 0x31, 0x97, 0x05, 0x11, 0x83, 0x05, 0xe1, 0x87, 0x73,
	0x3a, 0xb6, 0x39, 0x74, 0x33, 0xe1, 0x17, 0x2b, 0x28, 0x42, 0x5f, 0x43, 0x76, 0x83, 0xef, 0x61,
	0xce, 0x07, 0x34, 0x9f, 0xe5, 0x33, 0x6b, 0x4c, 0xcf, 0x90, 0x1b, 0x1c, 0x47, 0xdf, 0x41, 0x26,
	0x70, 0xcd, 0x6c, 0x72, 0xe5, 0x57, 0xf1, 0xa0, 0x44, 0xed, 0x41, 0xe9, 0xb9, 0xd7, 0x14, 0x88,
	0x51, 0xab, 0x62, 0x72, 0x55, 0x39, 0x72, 0x0f, 0x3c, 0x9f, 0xe5, 0xd3, 0xab, 0xb4, 0x61, 0x72,
	0x85, 0xd3, 0x24, 0xb8, 0x44, 0xdf, 0x81, 0x4f, 0x14, 0xcd, 0x61, 0xba, 0xcd, 0x34, 0x66, 0x0e,
	0x08, 0xaf, 0x75, 0xa8, 0xf2, 0xf8, 0xc7, 0x59, 0xfe, 0x93, 0x3b, 0x19, 0xda, 0xb6, 0xcc, 0xd7,
	0xaa, 0x39, 0x20, 0x78, 0xdf, 0xb3, 0x6f, 0xb9, 0xe6, 0xae, 0x00, 0x3d, 0x03, 0x5f, 0xa4, 0x11,
	0xcb, 0xf0, 0x1c, 0xc6, 0x76, 0x71, 0x98, 0xf6, 0xac, 0x15, 0xcb, 0xe0, 0xee, 0xea, 0xb0, 0xef,
	0x8c, 0x2e, 0x07, 0xa6, 0xe3, 0x1e, 0xce, 0x73, 0x17, 0xdf, 0xc5, 0x5d, 0x66, 0x65, 0xcd, 0xfd,
	0x7d, 0x0d, 0x51, 0x7d, 0xc4, 0x7a, 0xd4, 0x96, 0x12, 0x3b, 0x5c, 0x44, 0xdf, 0x06, 0x7d, 0x05,
	0x30, 0xa6, 0x8c, 0xb8, 0xd9, 0x62, 0x44, 0x02, 0x9e, 0xfe, 0x2c, 0x27, 0x9a, 0xaa, 0xf7, 0xfb,
	0xd7, 0x98, 0x38, 0xa3, 0x3e, 0x5b, 0xdc, 0x23, 0x17, 0xd9, 0x72, 0x81, 0xe8, 0x09, 0x44, 0x5d,
	0x8b, 0x91, 0x23, 0x25, 0x65, 0xa1, 0x98, 0x39, 0x3b, 0xe4, 0x26, 0x0b, 0xee, 0x95, 0x5a, 0x5c,
	0x87, 0x7d, 0x8c, 0x8b, 0xb6, 0xb9, 0x23, 0x29, 0x75, 0x1b, 0xda, 0xdb, 0x04, 0xfb, 0x18, 0xf4,
	0x19, 0x84, 0xd9, 0xf5, 0x90, 0x48, 0x69, 0x8e, 0x45, 0x37, 0xb1, 0xea, 0xf5, 0x90, 0x60, 0xae,
	0x47, 0xbf, 0x85, 0x14, 0x23, 0xaf, 0x99, 0x66, 0x10, 0xa6, 0x9b, 0x7d, 0x47, 0x3a, 0xe3, 0xc1,
	0x4b, 0x5e, 0xf0, 0x9b, 0x37, 0xee, 0xe9, 0x1e, 0x4e, 0xba, 0xf8, 0xaa, 0x07, 0x47, 0xbf, 0x87,
	0x07, 0x01, 0xf2, 0xf9, 0xcd, 0x7b, 0xe1, 0xeb, 0x4b, 0xee, 0xeb, 0x61, 0xf0, 0xc6, 0xad, 0x5f,
	0xd3, 0xa7, 0x7b, 0xf8, 0x98, 0xac, 0xa9, 0x7c, 0xdf, 0x85, 0x7f, 0x08, 0x10, 0xf5, 0x72, 0x80,
	0x8a, 0x70, 0xdc, 0xc4, 0x8d, 0x66, 0xa3, 0x55, 0xbe, 0xd0, 0x5a, 0x6a, 0x59, 0x6d, 0xb7, 0xb4,
	0x5a, 0xfd, 0x79, 0xf9, 0xa2, 0x56, 0xcd, 0xee, 0xe5, 0x92, 0x93, 0xa9, 0x1c, 0xab, 0x59, 0x63,
	0xbd, 0x6f, 0x1a, 0xe8, 0x09, 0x3c, 0x58, 0x47, 0xb6, 0xda, 0x95, 0x67, 0x35, 0x55, 0x55, 0xaa,
	0x59, 0x21, 0x97, 0x9e, 0x4c, 0xe5, 0x44, 0xcb, 0xad, 0x3d, 0x63, 0xc4, 0x40, 0x9f, 0xc1, 0xfd,
	0x75, 0xf4, 0xf9, 0x45, 0xa3, 0xa5, 0x54, 0xb3, 0x62, 0x0e, 0x26, 0x53, 0x39, 0x7a, 0xde, 0xa7,
	0x0e, 0xb9, 0xd5, 0xeb, 0x8b, 0x9a, 0xfa, 0xb4, 0x8a, 0xcb, 0x2f, 0xea, 0xd9, 0x90, 0xe7, 0xf5,
	0x85, 0xc9, 0x7a, 0x86, 0xad, 0xbf, 0xb2, 0x78, 0xe0, 0x78, 0x51, 0x86, 0x55, 0xe0, 0x58, 0x69,
	0xb5, 0x2f, 0xd4, 0x40, 0xe0, 0x89, 0xc9, 0x54, 0x8e, 0x28, 0x83, 0x21, 0xbb, 0xbe, 0xb1, 0x81,
	0x8f, 0x6b, 0xd7, 0xab, 0xca, 0x37, 0xb5, 0xfa, 0x2a, 0xec, 0xb6, 0x65, 0x90, 0x2b, 0xd3, 0x22,
	0x06, 0xfa, 0x1c, 0xa4, 0x75, 0x74, 0xf9, 0xfc, 0x5c, 0x69, 0xaa, 0x3c, 0xf0, 0xd4, 0x64, 0x2a,
	0xc7, 0xcb, 0x9d, 0x0e, 0x19, 0xb2, 0xdb, 0xb1, 0x58, 0xf9, 0x56, 0x39, 0x77, 0xb1, 0x21, 0x0f,
	0x8b, 0xc9, 0x1f, 0x48, 0x87, 0x11, 0xa3, 0xf0, 0x27, 0x01, 0xc2, 0x2e, 0x37, 0xd0, 0xa7, 0x70,
	0xb4, 0x34, 0x52, 0x5f, 0x36, 0x95, 0x40, 0xd0, 0xf1, 0xc9, 0x54, 0x0e, 0xd7, 0xa9, 0xe5, 0x36,
	0x36, 0x74, 0x13, 0xa4, 0x2a, 0xdf, 0xab, 0x59, 0xc1, 0x43, 0xb8, 0xdc, 0x41, 0xbf, 0x86, 0xfc,
	0x4d, 0x44, 0xbb, 0x59, 0x2d, 0xab, 0x8a, 0xa6, 0x5c, 0x28, 0xe7, 0x6a, 0x03, 0x97, 0x55, 0x25,
	0x2b, 0xe6, 0x0e, 0x27, 0x53, 0x39, 0x1b, 0x98, 0xe9, 0x9c, 0x09, 0x95, 0x04, 0xc4, 0x7c, 0x1a,
	0x15, 0xde, 0x09, 0x90, 0x0c, 0xdc, 0x23, 0xf4, 0x33, 0x48, 0x78, 0xaf, 0x8b, 0x6b, 0xe2, 0xcd,
	0xf2, 0x30, 0x8e, 0x73, 0xc1, 0x4b, 0xe2, 0xa0, 0x07, 0xe0, 0xfd, 0xd6, 0x2c, 0xca, 0xdb, 0x70,
	0x18, 0xc7, 0xf8, 0xba, 0x4e, 0xd1, 0xa7, 0x90, 0xf6, 0x54, 0xfa, 0xa5, 0xc3, 0x74, 0xff, 0x7d,
	0x14, 0xc6, 0x29, 0x2e, 0x2c, 0x7b, 0xb2, 0xf7, 0x3d, 0x5d, 0xc2, 0xef, 0x7b, 0xba, 0xac, 0x66,
	0x62, 0xe4, 0x3d, 0x33, 0xf1, 0xe6, 0xb4, 0x8d, 0x6e, 0x33, 0x6d, 0x79, 0x51, 0x9e, 0xd3, 0x5d,
	0x9f, 0x87, 0x4f, 0x20, 0xe6, 0x9f, 0x80, 0xa7, 0xe1, 0xf6, 0xc1, 0xb7, 0x80, 0xa0, 0xc7, 0x10,
	0x71, 0xdb, 0x92, 0xc1, 0x53, 0x92, 0x39, 0xdb, 0xe7, 0x58, 0x77, 0xd3, 0x06, 0x9f, 0x50, 0xd8,
	0xd3, 0x16, 0xfe, 0x23, 0xc2, 0xd1, 0xb9, 0x4d, 0x74, 0x46, 0x82, 0xad, 0xe1, 0x99, 0xd3, 0xfd,
	0x29, 0xcc, 0xc9, 0xaf, 0x20, 0x30, 0xe5, 0x5c, 0xd3, 0x08, 0x37, 0xcd, 0xce, 0x67, 0xf9, 0xd4,
	0xaa, 0x9c, 0xb5, 0x2a, 0x4e, 0xad, 0x60, 0x35, 0x03, 0x55, 0x01, 0x3e, 0x74, 0x08, 0x26, 0x9c,
	0xe5, 0xf8, 0x5b, 0xcd, 0x97, 0xd8, 0xee, 0xf3, 0xa5, 0xf0, 0x4e, 0x84, 0x4f, 0xbc, 0xbc, 0x6f,
	0xb4, 0xd1, 0xff, 0x77, 0x0d, 0x36, 0xb2, 0x18, 0xfe, 0x80, 0x2c, 0x46, 0x3e, 0x3a, 0x8b, 0xd1,
	0x0f, 0x98, 0xd2, 0x1b, 0x2f, 0xc2, 0xd8, 0x96, 0x2f, 0xc2, 0xef, 0xe1, 0x5e, 0x95, 0xf4, 0xc9,
	0x47, 0x64, 0xfb, 0x3e, 0x88, 0xa6, 0xe1, 0xbf, 0xf1, 0xa3, 0xf3, 0x59, 0x5e, 0xac, 0x55, 0xb1,
	0x68, 0x1a, 0x85, 0x37, 0x02, 0xc4, 0xdc, 0x6b, 0xb6, 0xb3, 0xc3, 0x53, 0x48, 0x0e, 0xfd, 0x60,
	0xb4, 0xa5, 0xe7, 0xcc, 0x7c, 0x96, 0x87, 0x45, 0x8c, 0xb5, 0x2a, 0x86, 0x05, 0xa4, 0x66, 0xb8,
	0x1f, 0x1a, 0xee, 0x1d, 0xb6, 0x77, 0xfb, 0x28, 0xe4, 0x26, 0x6e, 0x64, 0x0e, 0x4f, 0x1a, 0xf1,
	0xca, 0x7d, 0x4b, 0x83, 0x58, 0x02, 0x0a, 0x3d, 0x88, 0xf3, 0x66, 0xfd, 0x3f, 0x3f, 0x52, 0xe1,
	0xef, 0x02, 0x1c, 0xac, 0xcf, 0x8d, 0x9d, 0x77, 0xdd, 0xe0, 0xb3, 0xb8, 0x15, 0x9f, 0x37, 0xb8,
	0x14, 0xda, 0x92, 0x4b, 0xff, 0x16, 0xe0, 0x68, 0xf3, 0x03, 0x76, 0xe7, 0xb0, 0x6f, 0x6b, 0x85,
	0xe2, 0xd6, 0xad, 0xf0, 0x8e, 0x6f, 0xc4, 0xd0, 0x56, 0xdf, 0x88, 0xe1, 0x6d, 0xa6, 0xd6, 0xe7,
	0x7f, 0x15, 0x00, 0x56, 0xfc, 0x40, 0x8f, 0xe0, 0xe0, 0x79, 0x43, 0x55, 0xb4, 0x46, 0x53, 0xad,
	0x35, 0xea, 0x77, 0x3d, 0xde, 0x1e, 0xc2, 0x7e, 0x10, 0xf5, 0x52, 0x69, 0x65, 0x85, 0x5c, 0x6c,
	0x32, 0x95, 0x43, 0xee, 0x68, 0xcf, 0x41, 0x26, 0xa8, 0xad, 0x37, 0xb2, 0x62, 0x2e, 0x3a, 0x99,
	0xca, 0x62, 0x9d, 0xae, 0xfb, 0x2f, 0x57, 0x5a, 0x6a, 0xb9, 0xe6, 0x3e, 0xcd, 0xb8, 0x7f, 0x7f,
	0xb8, 0x57, 0xa4, 0x1f, 0xe6, 0x27, 0xc2, 0x9b, 0xf9, 0x89, 0xf0, 0xaf, 0xf9, 0x89, 0xf0, 0x97,
	0xb7, 0x27, 0x7b, 0x6f, 0xde, 0x9e, 0xec, 0xfd, 0xf3, 0xed, 0xc9, 0xde, 0x65, 0x94, 0xff, 0x21,
	0xf3, 0xe5, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x9a, 0xa8, 0xe8, 0x6d, 0x29, 0x12, 0x00, 0x00,
}

func (m *Electorate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Electorate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n1, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Version))
	}
	if len(m.Admin) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Admin)))
		i += copy(dAtA[i:], m.Admin)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Electors) > 0 {
		for _, msg := range m.Electors {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCodec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalElectorateWeight != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.TotalElectorateWeight))
	}
	if len(m.UpdateElectionRuleID) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.UpdateElectionRuleID)))
		i += copy(dAtA[i:], m.UpdateElectionRuleID)
	}
	return i, nil
}

func (m *Elector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Elector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Weight != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Weight))
	}
	return i, nil
}

func (m *ElectionRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElectionRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n2, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Admin) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Admin)))
		i += copy(dAtA[i:], m.Admin)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.VotingPeriodHours != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.VotingPeriodHours))
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintCodec(dAtA, i, uint64(m.Threshold.Size()))
	n3, err := m.Threshold.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.Quorum != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Quorum.Size()))
		n4, err := m.Quorum.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *Fraction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fraction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Numerator != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Numerator))
	}
	if m.Denominator != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Denominator))
	}
	return i, nil
}

func (m *TextProposalPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextProposalPayload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ElectorateUpdatePayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElectorateUpdatePayload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DiffElectors) > 0 {
		for _, msg := range m.DiffElectors {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCodec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n5, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.ElectionRuleID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ElectionRuleID)))
		i += copy(dAtA[i:], m.ElectionRuleID)
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintCodec(dAtA, i, uint64(m.ElectorateRef.Size()))
	n6, err := m.ElectorateRef.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if m.VotingStartTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.VotingStartTime))
	}
	if m.VotingEndTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.VotingEndTime))
	}
	if m.SubmissionTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.SubmissionTime))
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintCodec(dAtA, i, uint64(m.VoteState.Size()))
	n7, err := m.VoteState.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.Status != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Status))
	}
	if m.Result != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Result))
	}
	if m.Type != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Type))
	}
	if m.Details != nil {
		nn8, err := m.Details.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	return i, nil
}

func (m *Proposal_TextDetails) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TextDetails != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.TextDetails.Size()))
		n9, err := m.TextDetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Proposal_ElectorateUpdateDetails) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ElectorateUpdateDetails != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.ElectorateUpdateDetails.Size()))
		n10, err := m.ElectorateUpdateDetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *TallyResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TallyResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalYes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.TotalYes))
	}
	if m.TotalNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.TotalNo))
	}
	if m.TotalAbstain != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.TotalAbstain))
	}
	if m.TotalElectorateWeight != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.TotalElectorateWeight))
	}
	if m.Quorum != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Quorum.Size()))
		n11, err := m.Quorum.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintCodec(dAtA, i, uint64(m.Threshold.Size()))
	n12, err := m.Threshold.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *Vote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n13, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintCodec(dAtA, i, uint64(m.Elector.Size()))
	n14, err := m.Elector.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if m.Voted != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Voted))
	}
	return i, nil
}

func (m *CreateTextProposalMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTextProposalMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n15, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.ElectionRuleID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ElectionRuleID)))
		i += copy(dAtA[i:], m.ElectionRuleID)
	}
	if len(m.ElectorateID) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ElectorateID)))
		i += copy(dAtA[i:], m.ElectorateID)
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.StartTime))
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	return i, nil
}

func (m *CreateElectorateUpdateProposalMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateElectorateUpdateProposalMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n16, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.ElectorateID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ElectorateID)))
		i += copy(dAtA[i:], m.ElectorateID)
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.StartTime))
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if len(m.DiffElectors) > 0 {
		for _, msg := range m.DiffElectors {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCodec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DeleteProposalMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteProposalMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n17, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	return i, nil
}

func (m *VoteMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n18, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.ProposalID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ProposalID)))
		i += copy(dAtA[i:], m.ProposalID)
	}
	if len(m.Voter) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.Voter)))
		i += copy(dAtA[i:], m.Voter)
	}
	if m.Selected != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Selected))
	}
	return i, nil
}

func (m *TallyMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TallyMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n19, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.ProposalID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ProposalID)))
		i += copy(dAtA[i:], m.ProposalID)
	}
	return i, nil
}

func (m *UpdateElectorateMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateElectorateMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n20, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.ElectorateID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ElectorateID)))
		i += copy(dAtA[i:], m.ElectorateID)
	}
	if len(m.DiffElectors) > 0 {
		for _, msg := range m.DiffElectors {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCodec(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateElectionRuleMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateElectionRuleMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.Metadata.Size()))
		n21, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.ElectionRuleID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCodec(dAtA, i, uint64(len(m.ElectionRuleID)))
		i += copy(dAtA[i:], m.ElectionRuleID)
	}
	if m.VotingPeriodHours != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCodec(dAtA, i, uint64(m.VotingPeriodHours))
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintCodec(dAtA, i, uint64(m.Threshold.Size()))
	n22, err := m.Threshold.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	return i, nil
}

func encodeVarintCodec(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Electorate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovCodec(uint64(m.Version))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if len(m.Electors) > 0 {
		for _, e := range m.Electors {
			l = e.Size()
			n += 1 + l + sovCodec(uint64(l))
		}
	}
	if m.TotalElectorateWeight != 0 {
		n += 1 + sovCodec(uint64(m.TotalElectorateWeight))
	}
	l = len(m.UpdateElectionRuleID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	return n
}

func (m *Elector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovCodec(uint64(m.Weight))
	}
	return n
}

func (m *ElectionRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.VotingPeriodHours != 0 {
		n += 1 + sovCodec(uint64(m.VotingPeriodHours))
	}
	l = m.Threshold.Size()
	n += 1 + l + sovCodec(uint64(l))
	if m.Quorum != nil {
		l = m.Quorum.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	return n
}

func (m *Fraction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Numerator != 0 {
		n += 1 + sovCodec(uint64(m.Numerator))
	}
	if m.Denominator != 0 {
		n += 1 + sovCodec(uint64(m.Denominator))
	}
	return n
}

func (m *TextProposalPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ElectorateUpdatePayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DiffElectors) > 0 {
		for _, e := range m.DiffElectors {
			l = e.Size()
			n += 1 + l + sovCodec(uint64(l))
		}
	}
	return n
}

func (m *Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ElectionRuleID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = m.ElectorateRef.Size()
	n += 1 + l + sovCodec(uint64(l))
	if m.VotingStartTime != 0 {
		n += 1 + sovCodec(uint64(m.VotingStartTime))
	}
	if m.VotingEndTime != 0 {
		n += 1 + sovCodec(uint64(m.VotingEndTime))
	}
	if m.SubmissionTime != 0 {
		n += 1 + sovCodec(uint64(m.SubmissionTime))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = m.VoteState.Size()
	n += 1 + l + sovCodec(uint64(l))
	if m.Status != 0 {
		n += 1 + sovCodec(uint64(m.Status))
	}
	if m.Result != 0 {
		n += 1 + sovCodec(uint64(m.Result))
	}
	if m.Type != 0 {
		n += 1 + sovCodec(uint64(m.Type))
	}
	if m.Details != nil {
		n += m.Details.Size()
	}
	return n
}

func (m *Proposal_TextDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TextDetails != nil {
		l = m.TextDetails.Size()
		n += 2 + l + sovCodec(uint64(l))
	}
	return n
}
func (m *Proposal_ElectorateUpdateDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ElectorateUpdateDetails != nil {
		l = m.ElectorateUpdateDetails.Size()
		n += 2 + l + sovCodec(uint64(l))
	}
	return n
}
func (m *TallyResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalYes != 0 {
		n += 1 + sovCodec(uint64(m.TotalYes))
	}
	if m.TotalNo != 0 {
		n += 1 + sovCodec(uint64(m.TotalNo))
	}
	if m.TotalAbstain != 0 {
		n += 1 + sovCodec(uint64(m.TotalAbstain))
	}
	if m.TotalElectorateWeight != 0 {
		n += 1 + sovCodec(uint64(m.TotalElectorateWeight))
	}
	if m.Quorum != nil {
		l = m.Quorum.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = m.Threshold.Size()
	n += 1 + l + sovCodec(uint64(l))
	return n
}

func (m *Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = m.Elector.Size()
	n += 1 + l + sovCodec(uint64(l))
	if m.Voted != 0 {
		n += 1 + sovCodec(uint64(m.Voted))
	}
	return n
}

func (m *CreateTextProposalMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ElectionRuleID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ElectorateID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.StartTime != 0 {
		n += 1 + sovCodec(uint64(m.StartTime))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	return n
}

func (m *CreateElectorateUpdateProposalMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ElectorateID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.StartTime != 0 {
		n += 1 + sovCodec(uint64(m.StartTime))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if len(m.DiffElectors) > 0 {
		for _, e := range m.DiffElectors {
			l = e.Size()
			n += 1 + l + sovCodec(uint64(l))
		}
	}
	return n
}

func (m *DeleteProposalMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	return n
}

func (m *VoteMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ProposalID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.Selected != 0 {
		n += 1 + sovCodec(uint64(m.Selected))
	}
	return n
}

func (m *TallyMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ProposalID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	return n
}

func (m *UpdateElectorateMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ElectorateID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if len(m.DiffElectors) > 0 {
		for _, e := range m.DiffElectors {
			l = e.Size()
			n += 1 + l + sovCodec(uint64(l))
		}
	}
	return n
}

func (m *UpdateElectionRuleMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCodec(uint64(l))
	}
	l = len(m.ElectionRuleID)
	if l > 0 {
		n += 1 + l + sovCodec(uint64(l))
	}
	if m.VotingPeriodHours != 0 {
		n += 1 + sovCodec(uint64(m.VotingPeriodHours))
	}
	l = m.Threshold.Size()
	n += 1 + l + sovCodec(uint64(l))
	return n
}

func sovCodec(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCodec(x uint64) (n int) {
	return sovCodec(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Electorate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Electorate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Electorate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Electors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Electors = append(m.Electors, Elector{})
			if err := m.Electors[len(m.Electors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalElectorateWeight", wireType)
			}
			m.TotalElectorateWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalElectorateWeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateElectionRuleID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateElectionRuleID = append(m.UpdateElectionRuleID[:0], dAtA[iNdEx:postIndex]...)
			if m.UpdateElectionRuleID == nil {
				m.UpdateElectionRuleID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Elector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Elector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Elector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ElectionRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElectionRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElectionRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPeriodHours", wireType)
			}
			m.VotingPeriodHours = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPeriodHours |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quorum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Quorum == nil {
				m.Quorum = &Fraction{}
			}
			if err := m.Quorum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fraction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fraction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fraction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Numerator", wireType)
			}
			m.Numerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Numerator |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denominator", wireType)
			}
			m.Denominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Denominator |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextProposalPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextProposalPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextProposalPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ElectorateUpdatePayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElectorateUpdatePayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElectorateUpdatePayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiffElectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiffElectors = append(m.DiffElectors, Elector{})
			if err := m.DiffElectors[len(m.DiffElectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectionRuleID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElectionRuleID = append(m.ElectionRuleID[:0], dAtA[iNdEx:postIndex]...)
			if m.ElectionRuleID == nil {
				m.ElectionRuleID = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectorateRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ElectorateRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingStartTime", wireType)
			}
			m.VotingStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingStartTime |= github_com_iov_one_weave.UnixTime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingEndTime", wireType)
			}
			m.VotingEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingEndTime |= github_com_iov_one_weave.UnixTime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmissionTime", wireType)
			}
			m.SubmissionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmissionTime |= github_com_iov_one_weave.UnixTime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = append(m.Author[:0], dAtA[iNdEx:postIndex]...)
			if m.Author == nil {
				m.Author = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VoteState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Proposal_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= Proposal_Result(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Proposal_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TextProposalPayload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Proposal_TextDetails{v}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectorateUpdateDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ElectorateUpdatePayload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Proposal_ElectorateUpdateDetails{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TallyResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TallyResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TallyResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalYes", wireType)
			}
			m.TotalYes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalYes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNo", wireType)
			}
			m.TotalNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAbstain", wireType)
			}
			m.TotalAbstain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAbstain |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalElectorateWeight", wireType)
			}
			m.TotalElectorateWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalElectorateWeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quorum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Quorum == nil {
				m.Quorum = &Fraction{}
			}
			if err := m.Quorum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Elector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voted", wireType)
			}
			m.Voted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Voted |= VoteOption(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTextProposalMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTextProposalMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTextProposalMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectionRuleID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElectionRuleID = append(m.ElectionRuleID[:0], dAtA[iNdEx:postIndex]...)
			if m.ElectionRuleID == nil {
				m.ElectionRuleID = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectorateID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElectorateID = append(m.ElectorateID[:0], dAtA[iNdEx:postIndex]...)
			if m.ElectorateID == nil {
				m.ElectorateID = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= github_com_iov_one_weave.UnixTime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = append(m.Author[:0], dAtA[iNdEx:postIndex]...)
			if m.Author == nil {
				m.Author = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateElectorateUpdateProposalMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateElectorateUpdateProposalMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateElectorateUpdateProposalMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectorateID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElectorateID = append(m.ElectorateID[:0], dAtA[iNdEx:postIndex]...)
			if m.ElectorateID == nil {
				m.ElectorateID = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= github_com_iov_one_weave.UnixTime(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = append(m.Author[:0], dAtA[iNdEx:postIndex]...)
			if m.Author == nil {
				m.Author = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiffElectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiffElectors = append(m.DiffElectors, Elector{})
			if err := m.DiffElectors[len(m.DiffElectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteProposalMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteProposalMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteProposalMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposalID = append(m.ProposalID[:0], dAtA[iNdEx:postIndex]...)
			if m.ProposalID == nil {
				m.ProposalID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = append(m.Voter[:0], dAtA[iNdEx:postIndex]...)
			if m.Voter == nil {
				m.Voter = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selected", wireType)
			}
			m.Selected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Selected |= VoteOption(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TallyMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TallyMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TallyMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposalID = append(m.ProposalID[:0], dAtA[iNdEx:postIndex]...)
			if m.ProposalID == nil {
				m.ProposalID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateElectorateMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateElectorateMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateElectorateMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectorateID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElectorateID = append(m.ElectorateID[:0], dAtA[iNdEx:postIndex]...)
			if m.ElectorateID == nil {
				m.ElectorateID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiffElectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiffElectors = append(m.DiffElectors, Elector{})
			if err := m.DiffElectors[len(m.DiffElectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateElectionRuleMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateElectionRuleMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateElectionRuleMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &weave.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectionRuleID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElectionRuleID = append(m.ElectionRuleID[:0], dAtA[iNdEx:postIndex]...)
			if m.ElectionRuleID == nil {
				m.ElectionRuleID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPeriodHours", wireType)
			}
			m.VotingPeriodHours = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPeriodHours |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCodec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCodec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCodec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCodec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCodec(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCodec
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCodec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCodec
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCodec
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCodec
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCodec(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCodec
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCodec = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCodec   = fmt.Errorf("proto: integer overflow")
)
